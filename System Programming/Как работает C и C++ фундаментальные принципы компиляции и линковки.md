### **1. Введение**  
- C и C++ — это **компилируемые языки**, которые превращаются в машинный код.  
- Процесс включает **препроцессинг, компиляцию и линковку**.  
- Понимание этого процесса критично для эффективной работы с языками низкого уровня.  
---
#### **2. Три этапа работы C/C++ кода**  

##### **1. Препроцессинг**  
- **Директивы `#include`, `#define`, `#ifdef`** обрабатываются **препроцессором**.  
- Препроцессор **копирует содержимое заголовочных файлов** (`*.h`, `*.cpp`) в исходный код.  
- **Пример**:  
  ```cpp
  #include "main2.h"  // просто вставляет код из main2.h в текущий файл
  ```  
- **Итог**: формируется **translation unit** (единица трансляции) — "очищенный" файл для компиляции.  
##### **2. Компиляция**  
- Компилятор (например, `cl.exe` в MSVC, `g++` в GCC) переводит код в **объектные файлы** (`*.obj`, `*.o`).  
- **Объектный файл** содержит:  
  - Машинный код функций.  
  - **Символы** (имена функций, переменных) для линковки.  
  - Метаданные (типы, размеры данных).  
- **Ошибки компиляции**: синтаксические ошибки, неизвестные функции (если нет прототипа).  
##### **3. Линковка (Linking)**  
- **Линкер** (`link.exe`, `ld`) объединяет объектные файлы в **исполняемый файл** (`*.exe`, `*.so`, `*.dll`).  
- **Основные задачи линкера**:  
  - Найти **определения символов** (например, функции `bar()` из `main2.obj`).  
  - Разрешить **адреса вызовов функций**.  
  - Подключить **стандартную библиотеку (CRT — C Runtime)**.  
- **Ошибки линковки**:  
  - `undefined reference` (функция объявлена, но не определена).  
  - `multiple definitions` (одна функция определена в нескольких файлах).  
---
#### **3. Пример на практике**  

##### **Структура проекта**  
```
project/  
├── main.cpp      // вызов функции bar()  
├── main2.h       // объявление bar()  
└── main2.cpp     // определение bar()  
```  
##### **Шаги сборки**  
1. **Препроцессинг**:  
   ```cpp
   // main.cpp после #include "main2.h"
   int bar(int x);  // прототип из main2.h
   int foo() { return bar(42); }
   ```  
2. **Компиляция**:  
   ```bash
   cl /c main.cpp      → main.obj  
   cl /c main2.cpp     → main2.obj  
   ```  
3. **Линковка**:  
   ```bash
   link main.obj main2.obj /OUT:program.exe  
   ```  
   - Линкер находит `bar()` в `main2.obj` и подставляет адрес в `main.obj`.  

---
#### **4. Особенности C vs C++**  
- **C**:  
  - Нет перегрузки функций → компилятор ищет **точное совпадение имени**.  
  - Если функция не объявлена, компилятор **предполагает `int func()`**.  
- **C++**:  
  - Есть **перегрузка, пространства имён, шаблоны** → компилятор **требует объявления до использования**.  
  - **Name mangling**: имена функций искажаются (например, `bar(int)` → `?bar@@YAHH@Z`).  

---
#### **5. Зачем это знать?**  
- **Оптимизация**: ускорение сборки больших проектов (перекомпиляция только измененных файлов).  
- **Поиск ошибок**: понимание, на каком этапе (`препроцессинг`, `компиляция`, `линковка`) возникла проблема.  
- **Работа с библиотеками**: создание `.lib`, `.dll`, `.so` файлов.  
- **Low-level разработка**: написание драйверов, ОС, компиляторов.  

---
#### **6. Инструменты для анализа**  
- **Просмотр препроцессированного кода**:  
  ```bash
  g++ -E main.cpp  # GCC  
  cl /P main.cpp   # MSVC  
  ```  
- **Просмотр символов в объектных файлах**:  
  ```bash
  nm main.obj      # Linux  
  dumpbin /SYMBOLS main.obj  # Windows  
  ```  
- **Дисассемблирование**:  
  ```bash
  objdump -d program.exe  
  ```  

---
### **Вывод**  
C/C++ — это не просто "написать код и запустить". Это **контроль над каждым этапом**: от препроцессинга до линковки.  
- **Хотите глубже?** Изучайте:  
  - **Форматы объектных файлов** (ELF, COFF).  
  - **Динамическую линковку** (DLL, shared libraries).  
  - **Оптимизации компилятора** (inline, LTO).  
[[Системное программирование]]