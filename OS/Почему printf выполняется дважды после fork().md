#### **1. Что делает `fork()`?**  
- **`fork()`** — это системный вызов в Unix-подобных системах, который создает **точную копию текущего процесса** (дочерний процесс).  
- **Возвращаемое значение**:  
  - В **родительском процессе** — возвращает PID (идентификатор) дочернего процесса.  
  - В **дочернем процессе** — возвращает `0`.  
  - В случае ошибки — возвращает `-1`.  
#### **2. Разбор примера**  
Рассмотрим код:  
```c
#include <stdio.h>
#include <unistd.h>

int main() {
    fork();  // Создаем копию процесса
    printf("Всем привет!\n");
    return 0;
}
```  

**Что происходит**:  
1. Программа начинает выполняться в **родительском процессе** (PID = X).  
2. Вызывается `fork()` — создается **дочерний процесс** (PID = Y).  
   - Теперь есть **два процесса**: родительский (X) и дочерний (Y).  
3. Оба процесса продолжают выполнение **со следующей строки** (`printf`).  
   - Родительский процесс печатает "Всем привет!".  
   - Дочерний процесс **тоже печатает** "Всем привет!".  

**Итог**: На экране будет два сообщения, хотя `printf` в коде один.  

---  
### **3. Процессы vs Потоки**  
#### **Процесс**  
- **Определение**: Программа в состоянии выполнения.  
- **Изоляция**: У каждого процесса свое адресное пространство, PID, ресурсы.  
- **Пример**: Запуск двух копий браузера — это два независимых процесса.  
#### **Поток (Thread)**  
- **Определение**: Легковесная единица выполнения **внутри процесса**.  
- **Общее**: Потоки одного процесса делят память и ресурсы.  
- **Пример**: Веб-браузер использует потоки для параллельной загрузки изображений и JS.  

**Почему потоки быстрее процессов?**  
- Создание потока дешевле (не нужно копировать адресное пространство).  
- Переключение между потоками быстрее (они используют общую память).  

---  
### **4. Оптимизации: потоки в пользовательском режиме**  
- **Потоки в режиме ядра**: Управляются ОС (например, `pthread` в Linux).  
- **Потоки в пользовательском режиме**: Управляются библиотекой (например, Go-рутины).  
  - **Плюсы**: В 10–100 раз быстрее (нет переключения в ядро).  
  - **Минусы**: Если один поток блокируется (например, на I/O), блокируются **все** потоки процесса.  

---  
### **5. Как избежать двойного `printf` после `fork()`?**  
Используйте условие для разделения логики родителя и ребенка:  
```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Дочерний процесс (PID=%d)\n", getpid());
    } else {
        printf("Родительский процесс (PID=%d)\n", getpid());
    }
    return 0;
}
```  
**Вывод**:  
```
Родительский процесс (PID=1234)
Дочерний процесс (PID=1235)
```  

---  
### **6. Выводы**  
- **`fork()` дублирует процесс**, включая текущее состояние (например, буфер `printf`).  
- **Потоки** экономят ресурсы, но требуют аккуратной синхронизации.  
- **Микрооптимизации**: Потоки в пользовательском режиме — мощный инструмент для высоконагруженных приложений (например, веб-серверов).  

**Для глубокого понимания**:  
- Изучите `clone()` в Linux (гибрид `fork()` и потоков).  
- Поэкспериментируйте с `pthread` и сравните скорость создания 1000 процессов vs 1000 потоков.  

[[Операционныe системы]]