Аббревиатура SOLID представляет собой набор из пяти принципов объектно-ориентированного программирования и проектирования, которые помогают создавать более понятные, гибкие и поддерживаемые системы. 

* S - Single Responsibility Principle (Принцип единственной ответственности)

Принцип единственной ответственности утверждает, что у класса должна быть только одна причина для изменения, то есть класс должен иметь только одну обязанность или ответственность. Согласно принципу единственной ответственности, методы printReport и generateReport должны быть разделены на два разных класса, так как они имеют разные причины для изменения (например, изменения в логике печати и генерации отчета).
```C++
class Report {
public:
    void printReport() {
        // Код для печати отчета
    }
    
    void generateReport() {
        // Код для генерации отчета
    }
};
```

* O - Open/Closed Principle (Принцип открытости/закрытости)

Принцип открытости/закрытости гласит, что программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для модификации. Добавление новых фигур, таких как Triangle, не потребует изменения существующих классов.

```C++
class Shape {
public:
    virtual double area() const = 0;
};

class Circle : public Shape {
public:
    Circle(double radius) : radius(radius) {}
    double area() const override {
        return 3.14159 * radius * radius;
    }

private:
    double radius;
};

class Rectangle : public Shape {
public:
    Rectangle(double width, double height) : width(width), height(height) {}
    double area() const override {
        return width * height;
    }

private:
    double width;
    double height;
};
```

* L - Liskov Substitution Principle (Принцип подстановки Барбары Лисков)

Принцип подстановки Барбары Лисков утверждает, что объекты базового класса должны быть заменяемыми объектами производного класса без изменения правильности программы. Другими словами, функции, использующие указатели или ссылки на базовый класс, должны иметь возможность использовать объекты производных классов без необходимости знать об этом. Страус не может летать, поэтому наследование от Bird нарушает принцип подстановки. Лучше создать базовый класс Bird без метода fly или разделить классы.

```C++
class Bird {
public:
    virtual void fly() = 0;
};

class Sparrow : public Bird {
public:
    void fly() override {
        // Реализация полета воробья
    }
};

class Ostrich : public Bird {
public:
    void fly() override {
        // Страус не может летать, нарушение Liskov Substitution Principle
    }
};
```

* I - Interface Segregation Principle (Принцип разделения интерфейса)

Принцип разделения интерфейса гласит, что клиенты не должны зависеть от интерфейсов, которые они не используют. Это означает, что большие интерфейсы должны быть разделены на более мелкие и специфичные, чтобы клиенты использовали только те методы, которые им нужны. Роботы не едят, поэтому интерфейс IWorker должен быть разделен на два более специфичных интерфейса.
```C++
class IWorker {
public:
    virtual void work() = 0;
    virtual void eat() = 0;
};

class Worker : public IWorker {
public:
    void work() override {
        // Работает
    }

    void eat() override {
        // Ест
    }
};

class Robot : public IWorker {
public:
    void work() override {
        // Работает
    }

    void eat() override {
        // Роботы не едят, нарушение Interface Segregation Principle
    }
};
```

[[C++]]