IR — это структура данных или код, который используется внутри компиляторов и интерпретаторов для представления программы **между исходным кодом и машинным кодом**.  

IR проектируется так, чтобы:  
- Быть **проще для анализа и оптимизации**, чем исходный код.  
- Быть **независимым от исходного языка и целевой платформы**.  
- Позволять применять **многоуровневые оптимизации**.  
---
## **Зачем нужно IR?**  
1. **Упрощение компиляции**  
   - Один IR может использоваться для нескольких языков (C++, Rust → LLVM IR).  
   - Один IR может компилироваться под разные архитектуры (x86, ARM).  

2. **Оптимизации**  
   - Легче оптимизировать IR, чем исходный код или ассемблер.  

3. **Анализ кода**  
   - Статический анализ, проверка безопасности (например, в Clang Analyzer).  
---
## **Виды IR**  
### 1. **По уровню абстракции**  
| Тип               | Примеры                     | Характеристики                                |
| ----------------- | --------------------------- | --------------------------------------------- |
| **High-Level IR** | AST, Python bytecode        | Близок к исходному коду, сохраняет структуру. |
| **Mid-Level IR**  | LLVM IR, GCC GIMPLE         | Баланс между абстракцией и детализацией.      |
| **Low-Level IR**  | LLVM MIR, Java JVM bytecode | Близок к ассемблеру, но платформонезависим.   |
### 2. **По форме представления**  
- **Древовидный IR** (AST, SSA-деревья).  
- **Линейный IR** (инструкции в виде списка, например, LLVM IR).  
- **Графовый IR** (Control Flow Graph, Data Flow Graph).  
---
## **Примеры IR в реальных компиляторах**  

### 1. **LLVM IR**  
Используется в компиляторах Clang (C/C++), Rust, Swift.  
```llvm
define i32 @add(i32 %a, i32 %b) {
  %result = add i32 %a, %b
  ret i32 %result
}
```
- **Трёхадресный код**: `%result = add i32 %a, %b`.  
- **SSA (Static Single Assignment)**: Каждая переменная назначается один раз.  
### 2. **Java Bytecode**  
```java
aload_1       // Загрузить переменную 1 в стек
iload_2       // Загрузить int-переменную 2
iadd          // Сложить два числа
ireturn       // Вернуть результат
```
- **Стековая машина**: Операции работают с операндами в стеке.  
### 3. **GCC GIMPLE**  
Упрощённое представление в GCC:  
```c
x = a + b;
y = x * 2;
```
→  
```gimple
x_1 = a_2 + b_3;
y_4 = x_1 * 2;
```
---
## **SSA (Static Single Assignment)**  
Особая форма IR, где:  
- Каждая переменная **определяется ровно один раз**.  
- Используются **φ-функции (phi-nodes)** для слияния значений в условиях.  

Пример (псевдокод):  
```llvm
x = 10;
if (cond) {
  x = 20;  // x1 = 20
} else {
  x = 30;  // x2 = 30
}
y = x;     // y = φ(x1, x2)
```

В LLVM IR:  
```llvm
%x.initial = 10
br i1 %cond, label %if.true, label %if.false

if.true:
  %x.true = 20
  br label %merge

if.false:
  %x.false = 30
  br label %merge

merge:
  %y = phi i32 [%x.true, %if.true], [%x.false, %if.false]
```
---
## **Оптимизации на уровне IR**  
1. **Удаление мёртвого кода (DCE)**  
   ```llvm
   %x = 10     // Мёртвый код (не используется)
   %y = 20
   ret %y
   → 
   %y = 20
   ret %y
   ```

2. **Свёртка констант (Constant Folding)**  
   ```llvm
   %x = 2 + 3
   → 
   %x = 5
   ```

3. **Распространение копий (Copy Propagation)**  
   ```llvm
   %a = 10
   %b = %a
   %c = %b + 1
   → 
   %c = 10 + 1
   ```

4. **Инлайнинг функций (Inlining)**  
   ```llvm
   define i32 @add(i32 %a, i32 %b) { ... }
   %result = call @add(10, 20)
   →
   %result = 30
   ```
---
## **IR vs AST**  
| Характеристика         | AST                           | IR                                      |
| ---------------------- | ----------------------------- | --------------------------------------- |
| **Уровень абстракции** | Высокий (сохраняет синтаксис) | Средний/низкий (ближе к машинному коду) |
| **Оптимизации**        | Сложно выполнять              | Оптимизируется легко                    |
| **Использование**      | Парсинг, анализ кода          | Генерация кода, оптимизации             |

---
## **Вывод**  
IR — это **ключевой этап компиляции**, который:  
- Унифицирует обработку разных языков.  
- Позволяет применять сложные оптимизации.  
- Делает компиляторы модульными (фронтенд → IR → бэкенд).  

Без IR современные компиляторы (LLVM, GCC, JVM) были бы гораздо менее эффективны