#### **1. Проблема Race Condition (Состояние гонки)**
**Пример программы:**
```c
#include <stdio.h>
#include <pthread.h>

int counter = 0;

void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        counter++;  // Критическая секция
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, increment, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    printf("Counter = %d\n", counter);  // Может быть меньше 200000
    return 0;
}
```
**Почему возникает ошибка?**  
- Операция `counter++` **не атомарна**:  
  1. Чтение `counter` в регистр.  
  2. Увеличение регистра.  
  3. Запись обратно в `counter`.  
- Если два потока выполняют эти шаги **параллельно**, часть изменений теряется.  

**Решение**:  
- **Взаимное исключение (Mutual Exclusion)** — только один поток может выполнять критическую секцию (`counter++`) в момент времени.
---
#### **2. Алгоритм Петерсона (для 2 потоков)**
**Принцип работы**:  
- Каждый поток "выражает желание" войти в критическую секцию через флаг `flag[0]` или `flag[1]`.  
- Переменная `turn` определяет очередь.  

**Код**:  
```c
int flag[2] = {0, 0};
int turn = 0;

void enter_critical_section(int thread_id) {
    flag[thread_id] = 1;  // Я хочу войти
    turn = 1 - thread_id; // Пусть другой поток попробует
    while (flag[1 - thread_id] && turn == 1 - thread_id) {} // Активное ожидание
}

void leave_critical_section(int thread_id) {
    flag[thread_id] = 0;  // Я выхожу
}
```
**Проблемы**:  
- **Активное ожидание** (поток "крутится" в цикле, тратя CPU).  
- **Не работает для >2 потоков**.  
- **Переупорядочивание инструкций** процессором (нужен `Memory Barrier`).  

**Исправление**:  
```c
asm volatile ("" ::: "memory");  // Барьер памяти (GCC)
```
---
#### **3. Спинлоки (Spinlocks)**
**Принцип**:  
- **Атомарная** проверка и захват блокировки с помощью `Test-and-Set` (аппаратная инструкция).  

**Код**:  
```c
typedef struct {
    int locked;
} spinlock_t;

void spin_lock(spinlock_t *lock) {
    while (__sync_lock_test_and_set(&lock->locked, 1)) {}  // TAS
}

void spin_unlock(spinlock_t *lock) {
    __sync_lock_release(&lock->locked);  // Освобождение
}
```
**Плюсы**:  
- Быстрее, чем алгоритм Петерсона.  
- Подходит для коротких критических секций.  

**Минусы**:  
- Активное ожидание (тратит CPU).  
---
#### **4. Семафоры (Semaphores)**
**Принцип**:  
- Счётчик `sem` + очередь ожидания.  
- Операции:  
  - **P (wait)**: Если `sem > 0`, уменьшает `sem`; иначе блокирует поток.  
  - **V (signal)**: Увеличивает `sem`, разблокирует ждущий поток.  

**Пример (бинарный семафор = мьютекс)**:  
```c
#include <semaphore.h>
sem_t sem;
sem_init(&sem, 0, 1);  // Инициализация (1 = доступен)

sem_wait(&sem);  // P-операция
counter++;        // Критическая секция
sem_post(&sem);  // V-операция
```
**Проблемы**:  
- Можно забыть вызвать `sem_post` (deadlock).  
- Нет связи с защищаемыми данными.  
---
#### **5. Мониторы (Monitors)**
**Принцип**:  
- **Языковая конструкция**, объединяющая данные и методы их обработки с автоматической синхронизацией.  

**Пример в Java**:  
```java
class Counter {
    private int value = 0;
    public synchronized void increment() {  // Монитор на this
        value++;
    }
}
```
**Плюсы**:  
- Невозможно забыть разблокировать (синхронизация через `synchronized`).  
- Чистый и безопасный код.  

**Минусы**:  
- Требует поддержки языка (например, в C нет встроенных мониторов).  
---
#### **6. Итог: что использовать?**  
| **Механизм**       | **Когда применять**                              | **Пример**                |  
|---------------------|------------------------------------------------|---------------------------|  
| **Алгоритм Петерсона** | Для обучения (не для продакшена).              | Учебные проекты.          |  
| **Спинлоки**        | Короткие критические секции в ядре ОС.         | Реализация мьютексов.     |  
| **Семафоры**        | Управление доступом к ресурсам (например, пул потоков). | Ограничение числа подключений. |  
| **Мониторы**        | Высокоуровневые приложения (Java, C#).         | Многопоточные сервисы.    |  

**Главное правило**:  
> Всегда защищайте общие данные механизмами синхронизации. Даже если "ошибка проявляется редко" — она всё равно есть!

---
**Для глубокого погружения**:  
1. Изучите `pthread_mutex_t` в POSIX.  
2. Поэкспериментируйте с `std::mutex` в C++.  
3. Разберитесь, как работают `futex` в Linux (гибрид спинов и очередей ожидания).  

[[Operation system]]