#### **1. Основные понятия планирования**
**Переключение контекста (Context Switching)**  
- Сохранение состояния текущего процесса (регистры, стек, счётчик команд) и загрузка состояния нового процесса.  
- **Задача планировщика**: Определить, какой процесс будет выполняться следующим.  

**Критерии эффективности планирования**:  
- **Время отклика (Response Time)**: Как быстро система реагирует на запросы.  
- **Пропускная способность (Throughput)**: Количество задач, выполненных за единицу времени.  
- **Справедливость (Fairness)**: Равномерное распределение ресурсов.  
---
#### **2. Классы планировщиков**
| **Тип планировщика**       | **Цель**                                  | **Пример использования**          |  
|----------------------------|------------------------------------------|-----------------------------------|  
| **Пакетный (Batch)**       | Максимизация пропускной способности      | Научные вычисления, рендеринг.   |  
| **Интерактивный**          | Минимизация времени отклика              | ПК, смартфоны, GUI-приложения.   |  
| **Реального времени**      | Гарантированное выполнение к дедлайну    | Промышленные контроллеры, роботы.|  

---
#### **3. Уровни планирования**
1. **Долгосрочное**:  
   - Решает, какие процессы допустить в систему (например, при старте ОС).  
2. **Среднесрочное**:  
   - Управляет своппингом (выгрузкой процессов на диск).  
3. **Краткосрочное**:  
   - Выбирает процесс для выполнения на CPU (основной алгоритм планирования).  
---
#### **4. Основные алгоритмы планирования**
##### **1. FIFO (First-In, First-Out)**
- **Принцип**: Очередь процессов в порядке поступления.  
- **Плюсы**: Простота.  
- **Минусы**:  
  - Длинные задачи задерживают короткие («голодание»).  
  - Низкая отзывчивость.  

**Пример**:  
- Процессы: P1 (24 мс), P2 (3 мс), P3 (3 мс).  
- Среднее время ожидания:  
  - FIFO: (0 + 24 + 27)/3 = **17 мс**.  
  - Оптимальный порядок (P2 → P3 → P1): (0 + 3 + 6)/3 = **3 мс**.  
---
##### **2. SJN (Shortest Job Next)**
- **Принцип**: Сначала выполняются самые короткие задачи.  
- **Плюсы**: Минимизирует среднее время ожидания.  
- **Минусы**:  
  - Требует знания времени выполнения (не всегда возможно).  
  - Риск «голодания» длинных задач.  

**Вытесняющая версия (SRTF)**:  
- Прерывает текущий процесс, если появился более короткий.  
---
##### **3. Round Robin (RR)**
- **Принцип**: Каждый процесс получает фиксированный **квант времени** (например, 10–100 мс).  
- **Плюсы**:  
  - Справедливость (нет «голодания»).  
  - Высокая отзывчивость для интерактивных задач.  
- **Минусы**:  
  - Частые переключения контекста при малом кванте.  
  - Неэффективен для задач с интенсивным I/O.  

**Пример**:  
- Квант = 4 мс.  
- Процессы: P1 (5 мс), P2 (3 мс).  
  - P1: 4 мс → прерывание → остаток 1 мс.  
  - P2: 3 мс → завершён.  
  - P1: 1 мс → завершён.  
---
##### **4. Приоритетное планирование**
- **Принцип**: Каждому процессу назначается приоритет.  
- **Проблема**: «Голодание» низкоприоритетных задач.  
- **Решение**:  
  - **Старение (Aging)**: Постепенное повышение приоритета долго ожидающих процессов.  
---
##### **5. Многоуровневые очереди (MLQ)**
- **Принцип**:  
  - Процессы делятся на группы (например: системные, интерактивные, фоновые).  
  - Каждая очередь имеет свой алгоритм (например, RR для интерактивных, FIFO для фоновых).  
- **Плюсы**: Гибкость.  
- **Минусы**: Риск «голодания» низкоприоритетных очередей.  

**Многоуровневая очередь с обратной связью (MLFQ)**:  
- Динамически меняет приоритеты:  
  - Процессы, часто отдающие CPU (I/O-зависимые), повышаются в приоритете.  
  - «Жадные» процессы (CPU-bound) понижаются.  

**Пример**:  
- Очередь 1 (RR, квант=16 мс) → Очередь 2 (RR, квант=32 мс) → Очередь 3 (FIFO).  
- Новый процесс стартует в Очереди 1. Если не завершился — переходит в Очередь 2, затем в 3.  

---
#### **5. Проблемы и решения**
- **Проблема**: Интенсивные I/O-процессы не используют весь квант.  
  - **Решение**: Переключение на другой процесс при начале I/O.  
- **Проблема**: «Голодание» в MLQ.  
  - **Решение**: Периодическое повышение приоритета всех процессов.  

---
#### **6. Современные подходы**
- **Linux CFS (Completely Fair Scheduler)**:  
  - Использует «виртуальное время» для балансировки нагрузки.  
- **Windows**: Гибридный планировщик с приоритетами и квантованием.  

---
### **Итог**
- **FIFO/SJN** — для пакетных задач.  
- **Round Robin** — для интерактивных систем.  
- **MLFQ** — универсальный компромисс (используется в Unix/Linux).  
- **Ключевой принцип**: Нет «идеального» алгоритма — выбор зависит от workload (CPU-bound vs I/O-bound).  

**Оптимизация**:  
- Для веб-серверов: Приоритет I/O-потокам.  
- Для научных расчётов: FIFO/SJN.  

[[Operation system]]