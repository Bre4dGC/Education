#### **1. Три главные проблемы работы с памятью**
1. **Дефицит памяти**  
   - Физическая ОЗУ ограничена, а потребности процессов растут.
2. **Фрагментация**  
   - **Внутренняя**: Выделенный блок больше, чем нужно (например, выделено 4 КБ, а используется 1 КБ).  
   - **Внешняя**: Свободная память "разорвана" на мелкие несвязные участки.  
3. **Защита и изоляция**  
   - Процессы не должны мешать друг другу (например, доступ к чужой памяти).
---
#### **2. Виртуальная память как решение**
**Основная идея**:  
> Добавить уровень косвенности — пусть программы работают с **виртуальными адресами**, а ОС скрыто отображает их на физические.  

**Как это работает**:  
- Каждый процесс получает **собственное виртуальное адресное пространство** (например, 4 ГБ в 32-битной системе).  
- ОС и CPU совместно переводят виртуальные адреса в физические через **таблицы страниц**.  
- Если памяти не хватает, часть данных выгружается на диск (**своппинг**).

---
#### **3. Исторические методы управления памятью**
##### **Сегментация (устарело)**
- **Фиксированные сегменты**:  
  - Память делится на блоки одного размера.  
  - **Проблемы**: Внутренняя фрагментация (неэффективное использование).  
- **Переменные сегменты**:  
  - Размер сегмента равен размеру программы.  
  - **Проблемы**: Внешняя фрагментация (свободная память "размазана" мелкими кусочками).  

**Пример**: Intel x86 в 16-битном режиме использовал сегменты (регистры `CS`, `DS`).
##### **Страничная память (современный стандарт)**
- Память делится на **страницы** фиксированного размера (обычно 4 КБ).  
- **Таблица страниц** хранит соответствие:  
  - `Виртуальная страница (VPN)` → `Физическая страница (PFN)`.  
- **Плюсы**:  
  - Нет внешней фрагментации (страницы можно размещать в любом свободном месте).  
  - Поддержка защиты (каждая страница имеет флаги доступа: R/W/X).  

**Пример трансляции адреса**:  
```
Виртуальный адрес: 0x12345678  
→ VPN = 0x12345, смещение = 0x678  
→ По таблице страниц находим PFN (например, 0xABCDE)  
→ Физический адрес: 0xABCDE678
```

---
#### **4. Технические детали страничной памяти**
##### **Многоуровневые таблицы страниц (x86/x64)**
- **32-битный режим (4 ГБ адресного пространства)**:  
  - 2 уровня: `Каталог страниц (PD)` → `Таблица страниц (PT)`.  
- **64-битный режим**:  
  - 4–5 уровней (например, `PML4` → `PDP` → `PD` → `PT`).  
  - Адресуемое пространство обычно ограничено 48 битами (256 ТБ).  

**Зачем так много уровней?**  
- Экономия памяти: Не нужно хранить записи для неиспользуемых диапазонов.  
##### **Page Fault (Страничное прерывание)**
- Возникает, когда процесс обращается к странице, которой **нет в физической памяти**.  
- ОС может:  
  1. Загрузить страницу с диска (**своппинг**).  
  2. Создать новую (например, для стека).  
  3. Прекратить процесс (если доступ запрещён — Segmentation Fault).

---
#### **5. Оптимизации**
- **TLB (Translation Lookaside Buffer)**: Кэш трансляции адресов в CPU.  
- **Huge Pages (2 МБ/1 ГБ)**: Уменьшают нагрузку на TLB для больших данных.  
- **Copy-on-Write (CoW)**: При `fork()` дублируются только таблицы страниц, а данные копируются при изменении.  

---
#### **6. Пример: сколько памяти занимают таблицы страниц?**
- **32 ГБ ОЗУ** = 8 млн страниц по 4 КБ.  
- Каждая запись в таблице — 8 байт.  
- **Итого**: 8 млн × 8 Б = 64 МБ на таблицу.  
- Но у каждого процесса своя таблица! Решение:  
  - Часть таблиц хранится в свопе.  
  - Многоуровневость уменьшает объём (не все диапазоны используются).  

---
### **Вывод**
- **Виртуальная память** решает проблемы:  
  - **Дефицит**: Своппинг + изоляция процессов.  
  - **Фрагментация**: Страницы фиксированного размера.  
  - **Защита**: Флаги R/W/X в таблицах страниц.  
- **Современные ОС** используют **страничную организацию** с аппаратной поддержкой CPU.  
- **Page Faults** — это не ошибки, а часть работы менеджера памяти.  

**Для продвинутых**:  
- Изучите `mmap()` в Linux — как процессы могут работать с файлами как с памятью.  
- Разберитесь, как работает `malloc()` внутри (куча vs страницы).  

[[Operation system]] [[Memory]]