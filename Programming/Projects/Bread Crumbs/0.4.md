# Bread Crumbs: Демонстрация синтаксиса языка

**Bread Crumbs** — интерпретируемый язык программирования на основе C, созданный для экспериментов, тестирования, симуляций и декларативного программирования. Он поддерживает транзакционное выполнение, ветвление потоков, встроенные тесты и автоматическое решение систем уравнений. Синтаксис минималистичен, интуитивен и ориентирован на разработчиков, которые хотят быстро прототипировать, отлаживать и исследовать альтернативные сценарии.

---
## Основные особенности языка

- **Транзакционное выполнение**: Поддержка отката (`rollback`) и снапшотов состояния для безопасных экспериментов.
- **Ветвление выполнения**: Создание альтернативных сценариев (`fork`, `merge`) для тестирования гипотез.
- **Встроенные тесты**: Написание тестов прямо в коде с автоматической генерацией данных.
- **Декларативное программирование**: Решение систем уравнений и поиск параметров с помощью `solve`.
- **Отладка и объяснение**: Подробные трассировки (`trace`) и объяснения решений (`explain`).
- **Умная сборка мусора**: Региональная память для веток и транзакций, минимизирующая накладные расходы.
- **Интеграция с внешними библиотеками**: Поддержка FFI для вызова функций из C, Python и других языков.
---
## Типы данных

### Базовые типы
```rust
int8, int16, int32, int64     // Целые числа со знаком
uint8, uint16, uint32, uint64 // Целые числа без знака
float32, float64              // Числа с плавающей точкой
bool                          // Логический тип (true/false)
char                          // Символы
str                           // Строки
void                          // Отсутствие значения
tensor
uni
```
### Структуры данных
```rust
list<T>                // Динамический список
map<K, V>              // Ассоциативный массив
vector<T>              // Вектор фиксированного размера
tuple<T1, T2, ..., Tn> // Кортеж
```
### Пользовательские типы
```rust
type option<T> = some(T) | none     // Алгебраический тип (опциональное значение)
type result<T, E> = ok(T) | error(E)  // Тип для обработки ошибок
```
---
## Объявление переменных и констант
```rust
// Переменные (тип выводится автоматически, если не указан)
var x = 42              // int32
var name: str = "Bread"

// Константы (неизменяемые значения)
const PI: float64 = 3.14159
const MAX_USERS: int32 = 1000

// Списки и словари
var numbers: list<int32> = [1, 2, 3]
var settings: map<string, int32> = {"timeout": 30, "retries": 3}
```
---
## Ввод/вывод
```rust
// Вывод в консоль
print("Hello, World!")

// Чтение из консоли
var input: str
read(input)

// Работа с файлами
var content: string
read("file.txt", content)      // Чтение файла
write("out.txt", "some data")  // Запись в файл
```
---
## Условные конструкции
```rust
var x = 5
if x == 5 {
    print("x is 5")
} 
elif x > 5 {
    print("x is greater than 5")
} 
else {
    print("x is less than 5")
}
```
### Switch-подобная конструкция
```rust
var input = "yes"
match input {
    case "yes": accept()
        break
    case "no": decline()
        break
    default: think()
        break
}
```
---
## Циклы
### While
```rust
var i = 0
while i < 5 {
    print("i = ", i)
    i += 1
}
```
### For
```rust
// Классический for
for i = 0; i < 5; i++ {
    print("i = ", i)
}

// Итерация по диапазону
for i in 0..5 {
    print("i = ", i)
}

// Итерация по списку
var numbers = [10, 20, 30]
for n in numbers {
    print("Number: ", n)
}
```
---
## Функции
```swift
func ~<inheritanse> <name>(<args>) -> <return type> {}

// Простая функция
func:int add(var x: int32, var y: int32){
    return x + y
}

func->int add(var x: int32, var y: int32){
    return x + y
}

func add(var x: int32, var y: int32) -> int{
    return x + y
}

// Вызов функции
var result = add(2, 3)  // result = 5

// Функция с эффектами (например, ввод/вывод)
func log_change(x: int32) @io {
    print("x changed to ", x)
}
```
---
## Модули
```rust
// Импорт модуля
import math

// Использование функции из модуля
var sum = math.add(1, 3)
```
---
## Обработка ошибок
```rust
try {
    var cfg: str
    read("config.txt", cfg)
} catch {
    print("Error: Failed to read file")
}
```
---
## Структуры
```rust
struct Point {
    x: float
    y: float
}

var p = Point { x: 1.0, y: 2.0 }
print("Point: (", p.x, ", ", p.y, ")")
```
---
## Транзакции и откат (snapshot/rollback)
```rust
var x = 0

// Создание снапшота состояния
snapshot state1 = capture(x)

// Изменение переменной
x += 10
print("x after change: ", x)  // x = 10

// Откат к снапшоту
rollback state1
print("x after rollback: ", x)  // x = 0
```
### Откат в циклах
```rust
var x = 0
snapshot loop_start

while x < 5 {
    x += 1
    print("x = ", x)
}

rollback loop_start  // Откат всех изменений в цикле
print("x after rollback: ", x)  // x = 0
```
---
## Ветвление выполнения (fork/merge)
```rust
var x = 0

// Создание альтернативной ветки
fork timeline fail_case {
    x = 0
    fail("This case failed")
}

fork timeline success_case {
    x = 1
    print("Success case: x = ", x)
}

// Выбор успешной ветки
fork merge success_case
print("Final x: ", x)  // x = 1
```
### Симуляция сценариев
```rust
simulate scenarios {
    timeline A { x = 10 }
    timeline B { x = 20 }
    timeline C {
        solve x: int8 where x < 30
    }
}

choose C where x == 12
print("Chosen x: ", x)  // x = 12
```
---
## Декларативное программирование (solve)
```rust
// Поиск значений, удовлетворяющих условиям
solve x: int8, y: int8 {
    where x + y == 10, x > 0, y > 0
}
print("Solution: x = ", x, ", y = ", y)  // Например, x = 5, y = 5
```
### Объяснение решений
```rust
solve x: int8 {
    where x * 2 == 20, x < 15
}
explain x
// Вывод:
// Tried: x = 0..14
// Rejected:
//   x = 0 → constraint failed: x * 2 == 20
//   x = 1 → constraint failed: x * 2 == 20
//   ...
// Accepted: x = 10
```
---
## Встроенные тесты
```rust
test add_function {
    assert add(1, 2) == 3
    assert add(0, 0) == 0
}

test edge_case {
    solve x: int8 {
        where x * 3 == 99
    }
    assert x == 33
}
```
### Тестирование с ветвление
```rust
test overflow {
    fork timeline t1 {
        var x = 999
        if x >= 1000 {
            fail "X went over limit"
        }
    }
    rollback t1  // Откат, если тест провалился
}
```
---
## Отладка и трассировка
```rust
// Включение трассировки
trace level=debug

solve x: int8, y: int8 {
    where x + y == 10, x > 0, y > 0
}
print("Result: x = ", x, ", y = ", y)

// Вывод трассировки
// [DEBUG] Attempt 1: x = 1, y = 9
// [DEBUG] Attempt 2: x = 2, y = 8
// ...
// [DEBUG] Accepted: x = 5, y = 5
```
---
## Асинхронное программирование
```rust
async fn fetch_data(url: string) -> string {
    var data: string
    read(url, data) @io
    return data
}

var result = await fetch_data("https://api.example.com")
print("Data: ", result)
```
---
## Интеграция с внешними библиотеками (FFI)
```rust
extern "libm.so" fn sin(x: float64) -> float64

var result = sin(PI / 2)
print("sin(π/2) = ", result)  // 1.0
```
---
## Оптимизация и умная сборка мусора
- **Региональная память**: Каждая ветка (`fork`) или транзакция (`snapshot`) использует изолированный регион памяти. При `merge` регион интегрируется, при `rollback` — удаляется.
- **Автоматическая сборка мусора**: Комбинация подсчета ссылок и регионального подхода обеспечивает предсказуемую производительность без пауз.

---
## Пример комплексной программы
```rust
// Определение структуры
struct Config {
    var timeout: int32
    var retries: int32
}

// Функция с эффектами
fn load_config(path: string) -> Config @io {
    var data: string
    try {
        read(path, data)
        return Config { timeout: 30, retries: 3 }
    } catch {
        print("Error loading config")
        return Config { timeout: 10, retries: 1 }
    }
}

// Тестирование сценариев
simulate scenarios {
    timeline default {
        var cfg = load_config("config.txt")
        print("Default config: timeout = ", cfg.timeout)
    }
    timeline fallback {
        var cfg = Config { timeout: 5, retries: 2 }
        print("Fallback config: timeout = ", cfg.timeout)
    }
}

choose default where cfg.timeout > 10
print("Chosen config: timeout = ", cfg.timeout)

// Тест функции
test config_load {
    var cfg = load_config("test.txt")
    assert cfg.timeout == 30
    assert cfg.retries == 3
}

// Декларативное решение
solve x: int8, y: int8 {
    where x + y == 10, x > 2, y > 2
}
trace level=debug
explain x, y
print("Solution: x = ", x, ", y = ", y)
```