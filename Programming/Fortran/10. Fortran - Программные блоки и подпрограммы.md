### Подпрограммы
Подпрограмма в Фортране 90/95 имеет следующий синтаксис:
```fortran
subroutine subroutine_name[([dummy-argument-list])]
    [argument_declaration]
    ...
    return
end subroutine [subroutine_name]
```
Все переменные в программе на языке Фортран передаются в подпрограммы как ссылки на фактические переменные. Изменение параметра в подпрограмме приводит к изменению значений переменных в вызывающей подпрограмме или программе. Чтобы иметь возможность использовать переменные в списке аргументов, они должны быть объявлены в подпрограмме. Это делается сразу после объявления подпрограммы. По завершении работы подпрограммы управление возвращается вызывающей подпрограмме или программе с помощью команды **return**. В подпрограмме может быть несколько операторов возврата для возврата управления вызывающей подпрограмме или программе. Это показано в следующем примере.
```fortran
subroutine myproc(a,B,C)
    implicit none
    integer :: a
    real, dimension(a,*) :: B
    real, dimension(a) :: C
    .
    .
    .
    return
end subroutine
```
Подпрограмма вызывается с помощью оператора **call**. Приведенная выше подпрограмма вызывается следующим кодом.
```fortran
call myproc(a,B,C)
```
Следует отметить, что имена, используемые для переменных, являются локальными для каждой соответствующей подпрограммы. Имена переменных, передаваемых в качестве аргументов, не обязательно должны совпадать в вызывающей и вызываемой подпрограммах. Порядок аргументов определяет, как на переменные будут ссылаться из вызывающей подпрограммы.

В предыдущем примере показано, как сделать подпрограммы независимыми от размера задачи. Размеры массивов передаются с помощью параметра **a**, а не с помощью постоянных значений. Последний индекс массива можно не указывать, обозначив его *, так как он не нужен для определения адреса к элементу массива.
### Функции
Функции - это подпрограммы с возвращаемым значением, которые могут использоваться в различных видах выражений. Синтаксис таков:
```fortran
type function function_name([dummy-argument-list])
    [argument-declaration]
    ...
    function_name = return_value
    ...
    return
end function function_name
```

Следующий код показывает простое определение функции, возвращающей значение:
```fortran
real function f(x)
    real :: x
    f=sin(x)
    return
end function f
```
Возвращаемое значение определяется путем присвоения имени функции значения. Как видно из предыдущего примера. Функция вызывается путем указания имени функции и связанных с ней аргументов.
```fortran
a = f(y)
```
В следующем примере показано, как с помощью подпрограмм назначить матрицу элементов для трехмерного стержневого элемента. В примере также показано, как можно использовать динамическое выделение памяти для выделения матриц. См. также пример в разделе XX
```fortran
program subroutine_sample
	
    integer, parameter :: dp = &
    selected_real_kind(15,300)
	
    real(dp) :: ex(2), ey(2), ez(2), ep(2)
    real(dp), allocatable :: Ke(:,:)
	
    ep(1) = 1.0_dp
    ep(2) = 1.0_dp
    ex(1) = 0.0_dp
    ex(2) = 1.0_dp
    ey(1) = 0.0_dp
    ey(2) = 1.0_dp
    ez(1) = 0.0_dp
    ez(2) = 1.0_dp
	
    allocate(Ke(6,6))
	
    call bar3e(ex,ey,ez,ep,Ke)
    call writeMatrix(Ke)
	
    deallocate(Ke)
	
    stop
	
end program subroutine_sample
	
subroutine bar3e(ex,ey,ez,ep,Ke)
	
    implicit none
	
    integer, parameter :: dp = &
    selected_real_kind(15,300)
	
    real(dp) :: ex(2), ey(2), ez(2), ep(2)
    real(dp) :: Ke(6,6)
	
    real(dp) :: nxx, nyx, nzx
    real(dp) :: L, E, A
    real(dp) :: Kel(2,2)
    real(dp) :: G(2,6)
	
    ! Вычислите косинусы направлений	
    L = sqrt( (ex(2)-ex(1))**2 + (ey(2)-ey(1))**2 +  &
    (ez(2)-ez(1))**2 )
    nxx = (ex(2)-ex(1))/L
    nyx = (ey(2)-ey(1))/L
    nzx = (ez(2)-ez(1))/L
	
    ! Рассчитайте матрицу локальной жесткости	
    Kel(1,:) = (/  1.0_dp , -1.0_dp  /)
    Kel(2,:) = (/ -1.0_dp,   1.0_dp  /)
	
    Kel = Kel * (ep(1)*ep(2)/L)
	
    G(1,:) = (/ nxx, nyx, nzx, 0.0_dp, 0.0_dp, 0.0_dp /)
    G(2,:) = (/ 0.0_dp, 0.0_dp, 0.0_dp, nxx, nyx, nzx /)
	
    ! Вычислите преобразованную матрицу жесткости	
    Ke = matmul(matmul(transpose(G),Kel),G)
	
    return
	
end subroutine bar3e
	
subroutine writeMatrix(A)
	
    integer, parameter :: dp = &
    selected_real_kind(15,300)
	
    real(dp) :: A(6,6)
	
    ! Print matrix
	
    do i=1,6
        write(*,'(6G10.4)') (A(i,j), j=1,6)
    end do
	
    return
	
end subroutine writeMatrix
```

Программа выдает следующий результат.
```
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
0.1925    0.1925    0.1925    -.1925    -.1925    -.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
-.1925    -.1925    -.1925    0.1925    0.1925    0.1925
```
### Ключевое слово и необязательные аргументы
Иногда при реализации подпрограмм количество аргументов может увеличиваться, что усложняет использование лишних. Для решения этой проблемы можно написать подпрограммы-обертки, предоставляющие параметры по умолчанию для основных подпрограмм. Недостатком этого способа является необходимость дополнительного обслуживания подпрограмм-оберток при изменении основной подпрограммы. Fortran 2003 предлагает решение этой проблемы с помощью ключевых слов и необязательных аргументов. При объявлении параметров подпрограммы можно указать дополнительный атрибут параметра, **optional**. В следующем примере параметр **c** объявлен опциональным, и его не нужно указывать при вызове подпрограммы.
```fortran
subroutine dostuff(A, b, c)

    real    :: A(10,10)
    integer :: b
    integer, optional :: c
    ...
```

Процедура dostuff может быть вызвана двумя способами:
```fortran
call dostuff(A, b)    ! c опущен, так как является необязательным
call dostuff(A, b, c)
```
Если подпрограмма вызывается без необязательных параметров, она должна уметь определять, используется ли параметр, что можно сделать с помощью специальной функции present(...). Эта функция возвращает значение .true. если заданный параметр присутствует в вызове подпрограммы.

Помимо наличия необязательных параметров, параметры подпрограммы могут быть заданы именем параметра или ключевым словом. В следующем примере все эти приемы используются при реализации подпрограммы order_icecream. У этой подпрограммы есть только один обязательный аргумент - число. Остальные параметры являются необязательными, на что указывает символ optional в объявлении параметра.
```fortran
program optional_arguments
	
    implicit none
	
    call order_icecream(2)
    call order_icecream(2, 1)
    call order_icecream(4, 4, 2)
    call order_icecream(4, topping=3)
	
contains
	
subroutine order_icecream(number, flavor, topping)
	
    integer :: number
    integer, optional :: flavor
    integer, optional :: topping
	
    print *, number, 'icecreams ordered.'
	
    if (present(flavor)) then
        print *, 'Flavor is ', flavor
    else
        print *, 'No flavor was given.'
    end if
	
    if (present(topping)) then
        print *, 'Topping is ', topping
    else
        print *, 'No topping was given.'
    end if
	
end subroutine order_icecream
	
end program optional_arguments 
```
В последнем вызове ключевое слово **topping** используется для указания последнего необязательного аргумента, но оставляет параметр **flavor** неопределенным.
### Аргументы процедуры
Эффективной функцией, которая существует во многих других языках, является возможность передавать подпрограммы в качестве аргументов подпрограмм. Это может обеспечить эффективный способ предоставления алгоритмам функций, предоставляемых пользователем для использования в алгоритме. Например, в алгоритм численного дифференцирования можно передать функцию в качестве параметра подпрограммы. Теперь это возможно и в Fortran 2003.

Чтобы реализовать подпрограмму, принимающую функцию в качестве входного параметра, определение функции должно быть объявлено в объявлении параметров подпрограммы с помощью блока **интерфейса**.
```fortran
real function integrate(a, b, func)
	
    real :: a, b
	
    interface
        real function func(x)
            real, intent(in) :: x
        end function func
    end interface
	
    ...
```

Затем эту процедуру можно вызвать, предоставив функцию с тем же интерфейсом в качестве входных данных:
```fortran
real function myfunc(x)
	
    real :: x
	
    myfunc = sin(x)**2
	
end function myfunc
```

Тогда вызов функции integrate становится:
```fortran
area = integrate(0.0, 1.0, myfunc)
```

```fortran
module utils

    use mf_datatypes

	implicit none

contains

real(dp) function myfunc(x)
    real(dp), intent(in) :: x
	
	myfunc = sin(x)
	
end function myfunc

subroutine tabulate(startInterval, endInterval, step, func)
	real(8), intent(in) :: startInterval, endInterval, step
	real(8) :: x
	
	interface 
		real(8) function func(x)
			real(8), intent(in) :: x
		end function func
	end interface
	
	x = startInterval
	
	do while (x<endInterval) 
		print *, x, func(x)
		x = x + step
	end do
	
	return
end subroutine tabulate

end module utils 
```

```fortran
program procedures_as_arguments
	
    use mf_datatypes
    use utils
	
    implicit none
	
    call tabulate(0.0_dp, 3.14_dp, 0.1_dp, myfunc)
	
end program procedures_as_arguments
```
### Модули
Когда программы становятся большими, их часто приходится разбивать на более управляемые части. В других языках это часто достигается с помощью включаемых файлов или пакетов. В Fortran 77 такой функциональности нет. Исходные файлы могут быть сгруппированы в файлы, но стандартного способа включения определенных библиотек подпрограмм или функций в языке не существует. Препроцессор C часто используется для включения кода из библиотек в Fortran, но в самом языке он не стандартизирован.

В Fortran 90 было введено понятие модулей. Модуль Fortran 90 может содержать как переменные, параметры, так и подпрограммы. Это позволяет разделять программы на четко определенные модули, которые легче поддерживать. Синтаксис модуля похож на синтаксис основной программы в Fortran.
```fortran
module module-name
    [specification-stmts]
contains
    module-subprograms]
end module [module-name]]
```
Спецификация блока-stmts определяет переменные, которые доступны для программ или подпрограмм, использующих модуль. В блоке module--sub-programs объявляются подпрограммы модуля. Модуль может содержать только переменные, только подпрограммы или и то, и другое. Одно из применений этого - объявить переменные, общие для нескольких модулей, в отдельном модуле. Модули также являются хорошим способом разделить программу на логически последовательные части. Переменные и функции в модуле можно сделать частными для модуля, скрыв их для процедур, использующих этот модуль. Ключевые слова public и private могут использоваться для управления доступом к переменной или функции. В следующем коде переменная a скрыта от подпрограмм или программ, использующих этот модуль. Переменная b, однако, видна. Если в объявлении переменной ничего не указано, предполагается, что она является публичной.
```fortran
module mymodule
	
    integer, private :: a
    integer :: b
    ...
```

Возможность скрывать переменные в модулях позволяет разработчику скрыть детали реализации модуля, снижая риск случайной модификации переменных и использования подпрограмм, используемых в реализации.

Для доступа к подпрограммам и переменным в модуле используется оператор use. Это делает все открытые переменные и подпрограммы доступными в программах и других модулях. В следующем примере показано, как подпрограммы, использованные в предыдущих примерах, помещаются в модуль, truss, и используются из основной программы.
```fortran
module truss
	
    use mf_datatypes
    use mf_utils
	
    ! Объявление публичных переменных
	
    ! Переменные, которые видны другим программам
    ! и модулей
	
    ! Объявление приватных переменных
	
contains
	
subroutine bar3e(ex,ey,ez,ep,Ke)
	
    implicit none
	
    real(dp) :: ex(2), ey(2), ez(2), ep(2)
    real(dp) :: Ke(6,6)
	
    real(dp) :: nxx, nyx, nzx
    real(dp) :: L, E, A
    real(dp) :: Kel(2,2)
    real(dp) :: G(2,6)
	
    ! Вычисление косинусов направлений	
    L = sqrt( (ex(2)-ex(1))**2 + (ey(2)-ey(1))**2 &
            + (ez(2)-ez(1))**2 )
	
    nxx = (ex(2)-ex(1))/L
    nyx = (ey(2)-ey(1))/L
    nzx = (ez(2)-ez(1))/L
	
    ! Вычислите матрицу локальной жесткости	
    Kel(1,:) = (/  1.0_dp , -1.0_dp  /)
    Kel(2,:) = (/ -1.0_dp,   1.0_dp  /)
	
    Kel = Kel * (ep(1)*ep(2)/L)
	
    G(1,:) = (/ nxx, nyx, nzx, &
            0.0_dp, 0.0_dp, 0.0_dp /)
    G(2,:) = (/ 0.0_dp, 0.0_dp, 0.0_dp, &
            nxx, nyx, nzx /)
	
    ! Вычислить преобразованную матрицу жесткости	
    Ke = matmul(matmul(transpose(G),Kel),G)
	
    return
	
end subroutine bar3e
	
end module truss
```

Основная программа, использующая модуль фермы.
```fortran
program module_sample
	
    use mf_datatypes
    use mf_utils
    use truss
	
    implicit none
	
    real(dp) :: ex(2), ey(2), ez(2), ep(2)
    real(dp), allocatable :: Ke(:,:)
	
    ep(1) = 1.0_dp
    ep(2) = 1.0_dp
    ex(1) = 0.0_dp
    ex(2) = 1.0_dp
    ey(1) = 0.0_dp
    ey(2) = 1.0_dp
    ez(1) = 0.0_dp
    ez(2) = 1.0_dp
	
    allocate(Ke(6,6))
	
    call bar3e(ex,ey,ez,ep,Ke)
    call print_matrix(Ke)
	
    deallocate(Ke)
	
    stop
	
end program module_sample
```
Обратите внимание, что объявление **ap** в модуле **truss** используется для определения точности переменных в основной программе.
### Публичные и частные атрибуты
При реализации модулей некоторые подпрограммы и переменные используются только при реализации модуля. То есть некоторые переменные и подпрограммы не должны быть доступны пользователю модуля. Для управления доступом к переменным и подпрограммам в объявлении переменных и подпрограмм можно использовать атрибуты **private** и **public**. Переменная может быть объявлена приватной путем добавления ключевого слова **private** к списку атрибутов в объявлении, как показано в следующем примере:
```fortran
real, private :: a
```

Если атрибут **private** не указан, переменная по умолчанию объявляется как **public**. Если доступ к приватной переменной осуществляется из другого модуля, то главная программа выдаст ошибку компилятора.

Чтобы объявить подпрограмму или функцию приватной, она должна быть объявлена таковой в спецификационной части модуля, то есть перед ключевым словом **contains**. Следующий пример иллюстрирует эту концепцию.
```fortran
module mymodule
	
    private myprivatesub
	
contains
	
    subroutine myprivatesub
	
        print *, 'This subroutine can only be called from within the module.'
	
    end subroutine myprivatesub
	
    subroutine mypublicsub
	
        print *, 'This subroutine can be called from other modules.'
	
    end subroutine mypublicsub
	
end module mymodule
```
В этом примере **myprivatesub** может быть вызван только из модуля. Вызов его из другого модуля или основной программы приведет к ошибке компилятора. **myprivatesub** не объявлен как private в спецификационной части и, следовательно, может быть вызван из всех других модулей.
### Перегрузка
Поскольку Фортран является сильно типизированным языком, поддержка нескольких типов данных в одной подпрограмме невозможна и требует объявления отдельных уникальных подпрограмм. Чтобы упростить использование модулей и дать возможность пользователю модуля вызывать подпрограммы с разными типами данных, Fortran 90 поддерживает концепцию перегрузки. Используя перегрузку, компилятор может решить, какую рутину вызывать в зависимости от используемого типа данных. Однако для этого требуется специальное объявление в спецификации модуля.

Для иллюстрации этого реализована функция **func**, которая может принимать либо параметр с плавающей точкой, либо целочисленный параметр. Для реализации этой функции в части спецификации модуля добавляется объявление интерфейса для **func**:
```fortran
module overloaded
	
    interface func
        module procedure ifunc, rfunc
    end interface
    ...
```
Это указывает компилятору сопоставить **func**-функцию с функциями **ifunc** или **rfunc**, в зависимости от типа данных, используемого при вызове функции. **ifunc** и **rfunc** реализуются как обычные функции, как показано ниже:
```fortran
...
	
contains
	
integer function ifunc(x)
	
    integer, intent(in) :: x
    ifunc = x * 42
	
end function ifunc
	
real function rfunc(x)
	
    real, intent(in) :: x
    rfunc = x / 42.0
	
end function rfunc
	
end module overloaded
```

Теперь **func**-функцию можно вызывать, используя либо значения с плавающей точкой, либо целые значения, как показано в следующем примере:
```fortran
program overloading
	
    use special
	
    integer :: a = 42
    real :: b = 42.0
	
    a = func(a)
    b = func(b)
	
    print *, a
    print *, b
	
end program overloading
```

Запустив эту программу, вы получите следующий результат:
```
$ ./overloading
        1764
1.0000000000000000
```
Это означает, что **ifunc** вызывается при первом вызове **func**, а **rfunc** - при втором вызове **func**.
### Перегрузка операторов
Во многих современных языках, таких как C++ и Python, операторы могут быть перегружены для поддержки выражений для пользовательских типов данных. Это возможно и в Фортране. Чтобы проиллюстрировать, как это достигается, реализуется модуль **vector_operations**, позволяющий складывать векторы с помощью оператора +.

Сначала в нашем модуле **vector_operations** определяется тип вектора. Это фактический тип данных, который будет использоваться в вычисляемых выражениях.
```fortran
module vector_operations
	
    type vector
        real :: components(3)
    end type vector
    ...
```
Далее определяется интерфейс для перегрузки оператора +. Этот интерфейс указывает компилятору, какую функцию вызывать, когда он встречает выражение с нашим типом данных vector. В этом примере для оператора + будет вызвана **vector_plus_vector**-функция.
```fortran
...
interface operator(+)
    module procedure vector_plus_vector
end interface
...
```

На последнем этапе реализуется собственно функция сложения векторов. Эта функция должна иметь два входных параметра для векторов, которые будут добавлены в операцию. Она также должна возвращать тип данных **вектор**.
```fortran
...
contains
	
type(vector) function vector_plus_vector(v1, v2)
	
    type(vector), intent(in) :: v1, v2
    vector_plus_vector%components = v1%components + v2%components
	
end function vector_plus_vector
	
end module vector_operations
```
Новый тип данных вместе с определенным оператором + теперь можно использовать для реализации компактных выражений для векторной алгебры, как показано в следующем коде:
```fortran
program operator_overloading
	
    use vector_operations
	
    type(vector) :: v1
    type(vector) :: v2
    type(vector) :: v
	
    v1%components = (/1.0, 0.0, 0.0/)
    v2%components = (/0.0, 1.0, 0.0/)
	
    v = v1 + v2
	
    print *, v
	
end program operator_overloading
```

Запуск кода приведет к ожидаемому результату:
```
$ ./opoverload
  1.0000000000000000        1.0000000000000000        0.0000000000000000
```
Операторы -, * и / могут быть реализованы с помощью той же техники.
### Распределяемые фиктивные аргументы
```fortran
program allocatable_dummy
	
    implicit none
	
    real, allocatable :: A(:,:)
	
    call createArray(A)
	
    print *, size(A,1), size(A,2)
	
    deallocate(A)
	
contains
	
subroutine createArray(A)
	
    real, allocatable, intent(out) :: A(:,:)
	
    allocate(A(20,20))
	
end subroutine createArray
	
end program allocatable_dummy
```
### Распределяемые функции
```fortran
program allocatable_function
	
    implicit none
	
    real, allocatable, dimension(:) :: A
	
    A = create_vector(30)
    print *, size(A,1)
	
contains
	
function create_vector(n)
	
    real, allocatable, dimension(:) :: create_vector
    integer, intent(in) :: n
	
    allocate(create_vector(n))
	
end function create_vector
	
end program allocatable_function
```
### Подмодули (2003)
```fortran
module points
    type point
        real :: x, y
    end type point
	
    interface
        real module function point_dist(a, b)
            type(point), intent(in) :: a, b
        end function point_dist
    end interface
end module points
```

```fortran
submodule (points) points_a
	
contains
	
real module function point_dist(a,b)
    type(point), intent(in) :: a, b
    point_dist = sqrt((a%x-b%x)**2+(a%y-b%y)**2)
end function point_dist
	
end submodule points_a
```

```fortran
program submodules
	
    use points
	
    implicit none
	
end program submodules
```