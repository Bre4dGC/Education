В процедурном программировании данные и подпрограммы рассматриваются отдельно. Подпрограммы работают с предоставленными структурами данных и переменными. В объектно-ориентированном программировании данные и подпрограммы объединяются в объекты. Объектами в численных вычислениях могут быть различные типы матриц, частицы, векторы или решатели. Основные преимущества заключаются в том, что фактические структуры данных, используемые при реализации объекта, могут быть скрыты от пользователя объекта, что позволяет разработчику объекта улучшить реализацию, не затрагивая пользователей объектов (инкапсуляция). Другой важной особенностью объектно-ориентированного программирования является возможность наследования и расширения функциональности объектов (наследование). Это позволяет пользователям объектов и разработчикам расширять и модифицировать функциональность существующих объектов, опираясь на функциональность родительского объекта.

В Fortran 2003 объектно-ориентированные возможности были добавлены в язык, что сделало Fortran почти таким же функциональным, как и другие более современные языки. Большинство современных компиляторов Fortran сегодня поддерживают объектно-ориентированные возможности, добавленные в стандарт 2003 года, что позволяет разработчикам реализовывать на Fortran действительно объектно-ориентированные численные приложения.
В большинстве объектно-ориентированных языков программирования функциональность и структуры данных объектов определяются в классах. Классы можно рассматривать как шаблоны для объектов. Когда нужно создать объект, класс используется как шаблон для нового объекта. Созданные объекты также называются экземплярами класса.

В Fortran объектно-ориентированные возможности реализованы путем расширения концепций производных типов данных из Fortran 90. Производный тип данных теперь имеет раздел **содержит**, в котором указываются процедуры объектов. Производные типы данных теперь также по определению являются объектами или экземплярами производного типа.

Чтобы проиллюстрировать эти понятия, простой объект частицы определяется как объект в Fortran. Объект частицы определяется как производный тип данных в модуле particles. Чтобы исключить любые столкновения имен при создании новых объектов этого типа, производному типу присваивается имя **particle_class**. Это также соответствует объектно-ориентированной модели, согласно которой производные типы эквивалентны классам. Тогда начальное определение класса приобретает вид:
```fortran
module particles
	
    implicit none
	
    type particle_class
        real :: pos(3)
        real :: vel(3)
    end type particle_class
	
end module particles
```

В настоящее время это определение в точности соответствует производному типу данных в Fortran и может быть использовано как таковое. Создание экземпляра **particle_class** эквивалентно созданию переменной указанного производного типа данных:
```fortran
use particles
...
type(particle_class) :: particle
```

Для доступа к переменным экземпляра используется оператор **%**. В следующем примере **pos**-переменной присваивается координата $(0,0,0)$.
```fortran
particle % pos = (/ 0.0, 0.0, 0.0 /)
```

Однако обращение к переменным экземпляра противоречит принципам объектно-ориентированного программирования, где одним из важнейших аспектов является инкапсуляция данных и сокрытие внутренней работы объектов. Как использовать новые возможности Fortran, чтобы избежать необходимости прямого доступа к структурам данных? Первый аспект, который необходимо рассмотреть, - инициализация переменных экземпляра. Для этого в наш класс будет добавлен метод **init**. Во-первых, раздел **contains** со спецификацией процедуры для подпрограммы **init**. Поскольку в модуле не допускается дублирование имен подпрограмм, мы назначаем подпрограмме фактическую реализацию с помощью оператора =>. Обратите внимание, что в этом объявлении нет списка параметров. Во-вторых, чтобы отличить переменные-члены от других переменных в реализации класса, а также для предотвращения коллизий имен с именами методов доступа, переменные-члены имеют префикс **m_**. Таким образом, полный класс приобретает вид:
```fortran
module particles
	
    implicit none
	
    type particle_class
        real :: m_pos(3)
        real :: m_vel(3)
    contains
        procedure :: init => particle_init
    end type particle_class
    ...
```
Это объявление гласит, что класс **particle_class** имеет подпрограмму-член с именем **init**, определяемую позже в исходном коде подпрограммой **particle_init**. Чтобы завершить определение класса, подпрограмма **particle_init** должна быть добавлена в модуль **particles**.

Все подпрограммы-члены могут принимать первый фиктивный аргумент, содержащий ссылку на реальный экземпляр. Это позволит нам выполнить инициализацию на реальных структурах данных экземпляра. Тогда **init**-подпрограмма нашего класса частиц приобретает вид:
```fortran
module particles
	
...
	
contains
	
subroutine particle_init(this)
	
    class(particle_class) :: this
	
    this % m_pos = (/0.0, 0.0, 0.0/)
    this % m_vel = (/0.0, 0.0, 0.0/)
	
end subroutine particle_init
	
end module particles
```

В предыдущем примере подпрограмма **particle_init** имеет фиктивную переменную **this**, которая используется для доступа к реальным переменным экземпляра класса. Эта переменная автоматически передается в подпрограмму компилятором. Теперь можно инициализировать наш только что созданный экземпляр без прямого доступа к переменным-членам. Код для создания нового объекта и инициализации его структуры данных выглядит следующим образом:
```fortran
type(particle_class) :: particle

call particle % init
```

Фиктивный аргумент, **init**, можно не передавать в вызове **init**. Подобная концепция передачи переменной экземпляра в качестве аргумента в определении класса встречается и в Python, где в подпрограммах-членах используется специальная переменная **self**. Обратите внимание, что мы вызываем метод с **init**, а не собственно реализованную подпрограмму **particle_init**. Это позволяет нам иметь один и тот же интерфейс класса в нескольких классах.
### Методы доступа
Теперь класс имеет возможность инициализировать свои переменные данных. Однако у нас нет никаких способов получить доступ к переменным, не обращаясь к ним напрямую. Чтобы решить эту проблему, мы должны добавить специальные методы для доступа к внутренним переменным класса. Сначала в объявление класса добавляются методы для присвоения положения и скорости частицы:
```fortran
module particles
	
! ...
	
type particle_class
    real :: m_pos(3)
    real :: m_vel(3)
contains
    procedure :: init => particle_init
    procedure :: set_position => particle_set_position
    procedure :: set_velocity => particle_set_velocity
end type particle_class
	
contains
	
! ...
	
end module
```

После этого реализации этих подпрограмм добавляются в раздел **contains** **parcticles**-модулей:
```fortran
module particles
	
contains
	
! ...
	
subroutine particle_set_position(this, x, y ,z)
	
    class(particle_class) :: this
    real :: x, y, z
	
    this % m_pos = (/x, y, z/)
	
end subroutine particle_set_position
	
subroutine particle_set_velocity(this, vx, vy ,vz)
	
    class(particle_class) :: this
    real :: vx, vy, vz
	
    this % m_vel = (/vx, vy, vz/)
	
end subroutine particle_set_velocity
	
end module particles
```
Так же, как и в **init**-подпрограмме, **this** используется для доступа к переменным-членам экземпляра класса.

Теперь можно присваивать значения нашим экземплярам без прямого доступа к внутренним переменным-членам, как показано в следующем коде:
```fortran
call particle % set_position(1.0, 1.0, 1.0)
call particle % set_velocity(1.0, 1.0, 1.0)
```
Для получения значений из экземпляра необходимы две дополнительные подпрограммы, **get_position** и **get_velocity**, которые добавляются в определение и реализацию класса.

```fortran
module particles
	
implicit none
	
type particle_class
    real :: m_pos(3)
    real :: m_vel(3)
contains
    procedure :: init
    procedure :: set_position => particle_set_position
    procedure :: set_velocity => particle_set_velocity
    procedure :: get_position => particle_get_position
    procedure :: get_velocity => particle_get_velocity
end type particle_class
	
contains
	
! ...
	
subroutine particle_get_position(this, x, y ,z)
	
    class(particle_class) :: this
    real, intent(out) :: x, y, z
	
    x = this % m_pos(1)
    y = this % m_pos(2)
    z = this % m_pos(3)
	
end subroutine particle_get_position
	
subroutine particle_get_velocity(this, vx, vy ,vz)
	
    class(particle_class) :: this
    real, intent(out) :: vx, vy, vz
	
    vx = this % m_vel(1)
    vy = this % m_vel(2)
    vz = this % m_vel(3)
	
end subroutine particle_get_velocity
	
! ...
	
end module particles
```

Теперь можно получить доступ к переменным экземпляра с помощью этих подпрограмм, как показано в следующем примере:
```fortran
real :: x, y, z

! ...

call particle % get_position(x, y, z)
```

Также можно использовать функции для доступа к переменным экземпляра, как показано в следующем коде:
```fortran
real :: x, y, z

! ...

x = particle % x()
```
**x()** is a Fortran function member of **particle_class**.
### Красивый вывод
Другие функции, которые можно было бы интегрировать в класс, - это возможность красивой печати его переменных состояния. Рассмотрим следующую подпрограмму:
```fortran
subroutine particle_print(this)
	
    class(particle_class) :: this
	
    print*, 'Particle position'
    print*, '-----------------'
    write(*, '(3G10.3)') this % m_pos(1), this % m_pos(2), this % m_pos(3)
	
    print*, ''
	
    print*, 'Particle velocity'
    print*, '-----------------'
    write(*, '(3G10.3)') this % m_vel(1), this % m_vel(2), this % m_vel(3)
	
end subroutine particle_print
```

Эта подпрограмма позволит пользователю класса легко вывести переменные экземпляра в красивом формате без фактического доступа к переменным экземпляра:
```fortran
call particle % print
```

Этот код даст следующий результат:
#### Particle position
-----------------
1.00      1.00      1.00
#### Particle velocity
-----------------
1.00      1.00      1.00

Расширением этого может быть предоставление подпрограмм для чтения и записи экземпляра объекта в файл.
### Ограничение доступа
В предыдущих примерах кода внутренние переменные состояния были инкапсулированы с помощью методов доступа. Однако пользователь экземпляра все равно может получить доступ к переменной-члену. Это может привести к тому, что пользователи экземпляра будут изменять переменные напрямую, добровольно или по ошибке, что может привести к сложным ошибкам. Для решения этой проблемы Fortran позволяет классам помечать переменные экземпляра как частные, предотвращая доступ к ним. Добавление директивы **private** в объявление класса скрывает эти переменные от пользователей экземпляра, как показано в следующем коде:
```fortran
type particle_class
private
    real :: m_pos(3)
    real :: m_vel(3)
contains
```

Назначьте эти переменные, как показано в следующем примере,
```fortran
particle % m_pos(1) = 0.0
```

приведет к следующей ошибке компиляции:
```
    particle % m_pos(1) = 0.0
                1
Error: Component 'm_pos' at (1) is a PRIVATE component of 'particle_class'
\end{fortrancodeenv}
```

Это означает, что использование **private** в объявлении класса эффективно предотвратит ошибочный доступ пользователей к приватным переменным экземпляра любого класса.

Использование **private** перед объявлением переменной сделает все переменные приватными. Также можно выборочно сделать переменные публичными или приватными, удалив объявление private и добавив атрибут переменной **private** к объявлению переменной, как показано ниже:
```fortran
type particle_class
    real, private :: m_pos(3)
    real :: m_vel(3)
```
В этом коде **m_pos** является приватной, а **m_vel** - публичной, поскольку все переменные по умолчанию являются публичными.

Аналогичным образом можно запретить доступ к подпрограммам или функциям-членам, используя **private**- или **public**-атрибуты для каждого объявления подпрограммы, как показано в следующем примере:
```fortran
type particle_class
private
    real :: m_pos(3)
    real :: m_vel(3)
contains
    procedure :: init => particle_init
    procedure :: set_position => particle_set_position
    procedure :: set_velocity => particle_set_velocity
    procedure :: get_position => particle_get_position
    procedure :: get_velocity => particle_get_velocity
    procedure :: print => particle_print
    procedure, private :: setup => particle_setup
end type particle_class
```
Здесь добавлен приватный метод **setup**, который может быть вызван только для подпрограмм-членов класса **particle**.
### Расширение существующих классов
Классы в Фортране могут быть расширены с помощью специального атрибута **extends** в определении типа. В следующем примере предыдущий класс **particle_class** расширяется классом **sphere_particle_class** для работы со сферическими частицами.
```fortran
type, extends(particle_class) :: sphere_particle_class
private
    real :: m_radius
contains
    procedure :: set_radius => sphere_set_radius
    procedure :: get_radius => sphere_get_radius
end type sphere_particle_class
```
В определении типа добавлена приватная переменная-член **m_radius** и методы доступа к ней **set_radius** и **get_radius**. Методы доступа аналогичны методу доступа класса **particle_class**.
```fortran
subroutine sphere_set_radius(this, r)
	
    class(sphere_particle_class) :: this
    real :: r
	
    this % m_radius = r
	
end subroutine sphere_set_radius
	
real function sphere_get_radius(this)
	
    class(sphere_particle_class) :: this
	
    get_radius = this % m_radius
	
end function sphere_get_radius
```
Приведенное выше определение типа отменяет существующую **init**-рутину из **particle_class**. Это означает, что существующая процедура инициализации не будет вызвана. Чтобы решить эту проблему, **sphere_init**-рутина должна вызывать существующую **particle_init**-рутину из расширенного класса. Ниже показана процедура инициализации **sphere_init**:
```fortran
subroutine sphere_init(this)

    class(sphere_particle_class) :: this

    ! --- Вызов унаследованной процедуры инициализации.

    call this % particle_class % init()

    this % m_radius = 1.0

end subroutine sphere_init
```

Формат вызова унаследованной подпрограммы следующий:
```fortran
call [instance reference] \% [type definition name] \% [routine name]
```