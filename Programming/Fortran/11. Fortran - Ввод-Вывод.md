Ввод и вывод данных на различные устройства, такие как экран, клавиатура и файлы, осуществляется с помощью команд **read** и **write**. Синтаксис этих команд следующий:
```fortran
read(u, fmt) [list]
write(u, fmt) [list]
```
**u** - это устройство, которое используется для чтения или записи. Если в качестве устройства используется звездочка (*), то используются стандартный вывод и стандартный ввод (экран, клавиатура или трубы).

**fmt** - это строка, описывающая, как следует читать или записывать переменные. Это часто важно при записи результатов в текстовые файлы, чтобы сделать их более удобочитаемыми. Если используется звездочка (*), то применяется так называемый свободный формат, без специального форматирования. Строка формата состоит из одного или нескольких спецификаторов формата, которые имеют общий вид:
```fortran
[repeat-count] format-descriptor w[.m]
```
где **repeat-count** - количество переменных, к которым применяется данный формат. **format-descriptor** определяет тип спецификатора формата. **w** определяет ширину поля вывода, а **m** - количество значащих цифр или десятичных знаков в выводе. В следующем примере выводится несколько чисел с использованием различных спецификаторов формата, а в таблице~ref{table:formatkoder} приведены наиболее часто используемые спецификаторы формата.

```fortran
program formatting
	
    implicit none
	
    integer, parameter :: dp = &
            selected_real_kind(15,300)
	
    write(*,'(A15)') '123456789012345'
    write(*,'(G15.4)') 5.675789_dp
    write(*,'(G15.4)') 0.0675789_dp
    write(*,'(E15.4)') 0.675779_dp
    write(*,'(F15.4)') 0.675779_dp
    write(*,*)         0.675779_dp
    write(*,'(I15)')   156
    write(*,*) 156
	
    stop
	
end program formatting
```

Программа выдает следующий результат:
```
123456789012345
    5.676
    0.6758E-01
    0.6758E+00
        0.6758
0.675779000000000
            156
        156
```
Во время вывода невидимый курсор перемещается слева направо. Для перемещения этого курсора используются спецификаторы формата TR:math:n и T:math:n. TR:math:n перемещает курсор на $n$ позиций вправо от предыдущей позиции. T:math:n помещает курсор в позицию . Рис. 2 показывает, как это может быть использовано в операторе записи.
![[format_positioning.svg|900]]
Рис. 2 Позиционирование вывода в Fortran 90/95

Подпрограммы вывода в Fortran изначально предназначались для использования на строчных принтерах, где первым символом был управляющий символ. Следствием этого является то, что по умолчанию эти подпрограммы всегда начинают вывод со второй позиции. На современных компьютерах это не является проблемой, и первый символ может быть использован для печати. Для печати с первого символа можно использовать спецификатор формата **T1**, чтобы поместить курсор в первую позицию. Следующий код пишет ''Hej hopp!'', начиная с первой позиции.
```fortran
write(*,'(T1,A)') 'Hej hopp!'
```

Более подробное описание доступных спецификаторов формата в Фортране дано в книге Metcalf and Reid metcalfreid18
### Чтение и запись из файлов
Подпрограммы ввода и вывода можно также использовать для записи данных в файлы и из них. Это достигается путем связывания файла в файловой системе с номером единицы файла и использования этого номера в операторах **read** и **write** для направления ввода и вывода в нужные файлы. Файл ассоциируется, открывается, с номером единицы хранения с помощью **open**-выражения. Когда операции с файлом завершены, он закрывается с помощью оператора **close**.

Номер файловой единицы - это целое число, обычно от 1 до 99. Во многих системах файловая единица под номером 5 является клавиатурой, а единица 6 - дисплеем. Поэтому рекомендуется избегать использования этих номеров в файловых операциях.

В операторе **open** указываются свойства открываемых файлов, например, существует ли уже файл, как осуществляется доступ к файлу (чтение или запись) и имя файла, используемое в файловой системе.

Пример чтения и записи файла приведен в следующем примере.
```fortran
program sample2
	
    use mf_datatypes
	
    implicit none
	
    real(dp), allocatable :: infield(:,:)
    real(dp), allocatable :: rowsum(:)
	
    integer :: rows, i, j
	
    !  Номера единиц хранения файлов
    integer, parameter :: infile = 15
    integer, parameter :: outfile = 16
	
    !  Распределите матрицы
    rows=5
    allocate(infield(3,rows))
    allocate(rowsum(rows))
	
    !  Откройте файл 'indata.dat' для чтения
    open(unit=infile,file='indata.dat',&
        access='sequential',&
        action='read')
	
    !  Откройте файл 'utdata.dat' для записи
    open(unit=outfile,file='utdata.dat',&
        access='sequential',&
        action='write')
	
    !  Чтение входных данных из файла
    do i=1,rows
        read(infile,*) (infield(j,i),j=1,3)
        rowsum(i)=&
                infield(1,i)+infield(2,i)+infield(3,i)
        write(outfile,*) rowsum(i)
    end do
	
    !  Закрыть файлы	
    close(infile)
    close(outfile)
	
    !  Свободная используемая память	
    deallocate(infield)
    deallocate(rowsum)
	
    stop
	
end program sample2
```
В этом примере с помощью **open**-статей открываются 2 файла, ffname{indata.dat} и ffname{utdata.dat}. С помощью **read**-статьи из файла ffname{indata.dat} считываются пять строк с 3 числами в каждой строке. Сумма каждого ряда вычисляется и записывается с помощью **write**-статьи в файл ffname{utdata.dat}. Наконец, файлы закрываются с помощью **close**-статьи.
### Динамические коды формата
Одна из проблем, возникающих при написании форматированного вывода, заключается в том, как обрабатывать вывод данных, в которых количество столбцов неизвестно на момент компиляции. Для решения этой проблемы можно применить специальную технику, использующую строки в качестве единиц файла. Для иллюстрации этой техники мы реализуем подпрограмму **writeArray**, которая принимает на вход массив произвольного размера и пытается его красиво распечатать. Сначала мы объявляем модуль подпрограммы и определяем размер входящего массива:
```fortran
subroutine writeArray(A)
	
    real(8), dimension(:,:) :: A
    integer :: rows, cols, i, j
    character(255) :: fmt
	
    rows = size(A,1)
    cols = size(A,2)
	
    ...
```

Далее мы используем **write**-statement, который вместо номера единицы файла принимает строку **fmt** и использует ее в качестве выходного файла. В операторе **write** мы записываем код формата, необходимый для печати входящего массива, который затем сохраняется в строке **fmt**.
```fortran
...
write(fmt, '(A,I1,A)') '(',cols, 'G8.3)'
...
```

Сгенерированный код формата теперь можно использовать при печати входящего массива **A**.
```fortran
...
   do i=1,rows
       print fmt, (A(i,j), j=1,cols)
   end do

   return
end subroutine writeArray
```

В следующей основной программе реализованная подпрограмма **writeArray** используется для печати матрицы 6 на 6.
```fortran
program dynamic_fcodes
	
    use array_utils
	
    real(8) :: A(6,6)
	
    A = 42.0_8
	
    call writeArray(A)
	
end program dynamic_fcodes
```

Результат форматирования показан ниже:
```
$ ./dynamic_fcodes
42.0    42.0    42.0    42.0    42.0    42.0
42.0    42.0    42.0    42.0    42.0    42.0
42.0    42.0    42.0    42.0    42.0    42.0
42.0    42.0    42.0    42.0    42.0    42.0
42.0    42.0    42.0    42.0    42.0    42.0
42.0    42.0    42.0    42.0    42.0    42.0
```
### Ввод/вывод именных списков
Стандартным способом записи и чтения текстовых файлов в Фортране является использование списочного ввода-вывода. Это означает указание списка переменных для чтения или записи с помощью **read**- и **write**-условий. Фортран автоматически справится с преобразованием типов данных в текстовый формат и обратно. Более гибким способом обработки ввода-вывода текстовых файлов является использование списков имен. Именованные списки можно рассматривать как именованные списки переменных, которые будут использоваться для чтения или записи. В этой схеме переменные можно читать и записывать в файлы с помощью имен. Чтобы записать переменные и данные с помощью этой техники, переменные должны быть перечислены с помощью специального оператора **namelist**, как показано ниже:
```fortran
integer :: no_of_eggs, litres_of_milk, kilos_of_butter, list(5)
namelist /food/ no_of_eggs, litres_of_milk, kilos_of_butter, list
```

Здесь задан список имен, **food**, состоящий из указанных переменных. Переменные в namelist могут быть любого типа. Для записи переменных в файл можно использовать ключевое слово **nml** в **read**- и **write**-statements, чтобы указать, какой namelist должен быть использован.

Список имен в текстовом файле начинается с символа &, за которым следует имя переменной, затем перечисляются пары переменных списка, разделенные запятыми. Список завершается одиночным символом /. В следующем примере показаны 2 записи списка в текстовом файле:
```fortran
&food litres_of_milk=5, no_of_eggs=12, kilos_of_butter=42, list=1,2,3,4,5 /
&food litres_of_milk=6, no_of_eggs=24, kilos_of_butter=84, list=2,3,4,5,6 /
```

Из открытого файла можно считывать несколько записей списка имен. Следующий код показывает, как из открытого файла считываются 2 записи namelist типа **food**:
```fortran
open(unit=ir, file='food.txt', status='old')
read(ir, nml=food)
print *, no_of_eggs, litres_of_milk, kilos_of_butter
read(ir, nml=food)
print *, no_of_eggs, litres_of_milk, kilos_of_butter
close(unit=ir)
```

Выполнение этого кода дает следующий результат:
```
12           5          42
24           6          84
```

fmode

Запись с использованием пофамильного ввода-вывода выполняется так же, как и чтение. Следующий код показывает, как те же переменные namelist записываются в namelist:
```fortran
open(unit=iw, file='food2.txt', status='new')
write(iw, nml=food)
close(unit=iw)
```

Ниже показано содержимое записанного файла **food2.txt**:
```
&FOOD
NO_OF_EGGS=         24,
LITRES_OF_MILK=          6,
KILOS_OF_BUTTER=         84,
LIST=          2,          3,          4,          5,          6,

/
```
Обратите внимание, что в Фортране всегда используется верхний регистр для имен переменных в записанном файле.

```fortran
program namelist_io
	
    implicit none
	
    integer, parameter :: ir = 15
    integer, parameter :: iw = 16
    integer :: no_of_eggs, litres_of_milk, kilos_of_butter, list(5)
    namelist /food/ no_of_eggs, litres_of_milk, kilos_of_butter, list
	
    list = (/1, 2, 3, 4, 5 /)
    no_of_eggs = 1
    litres_of_milk = 2
    kilos_of_butter = 4
	
	
    open(unit=ir, file='food2.txt', status='unknown')
    read(ir, nml=food)
    print *, no_of_eggs, litres_of_milk, kilos_of_butter
	
    !read(ir, nml=food)
    !print *, no_of_eggs, litres_of_milk, kilos_of_butter
    !close(unit=ir)
	
    open(unit=iw, file='food2.txt', status='replace')
    write(iw, nml=food)
    close(unit=iw)
	
end program namelist_io
```
### Неформатированный ввод/вывод
В предыдущих разделах данные считывались и записывались в текстовом формате, удобном для чтения человеком. Для больших структур данных это может быть очень неэффективно. Чтобы решить эту проблему, Fortran может также записывать данные в своем родном двоичном формате непосредственно на диск. Это позволяет экономить место, а также считывать и записывать данные на диск гораздо быстрее. Однако двоичный формат не стандартизирован и различается на разных аппаратных платформах, что не позволяет использовать файлы на разном оборудовании.

Для чтения и записи двоичных данных используются те же операторы **read**- и **write**-, что и раньше, но без опций форматирования. Запись массива на диск в двоичном виде может быть выполнена с помощью одного простого оператора:
```fortran
real :: A(100)
...
write(iw) A
```

Чтение того же массива с диска осуществляется так же просто, с помощью **read**-statement.
```fortran
real :: A(100)
...
read(ir) A
```
Также можно записать на диск несколько переменных, используя несколько операторов **write**.
```fortran
real :: A(100), B(200)
...
write(iw) A
write(iw) B
```

Однако важно отметить, что данные должны быть считаны в том же порядке, в каком они были записаны. Таким образом, код для считывания данных становится:
```fortran
real :: A(100), B(200)
...
read(ir) A
read(ir) B
```

Чтобы разрешить чтение и запись неформатированных файлов ввода-вывода (бинарных файлов), в команду **open** необходимо добавить ключевое слово **form='unformatted'**.
```fortran
real :: A(100), B(200)
...
open(unit=ir, file='arrays.dat', form='unformatted')
read(ir) A
read(ir) B
close(ir)
```
Концепция неформатированного ввода-вывода проиллюстрирована на более крупном примере. В этом примере массив производного типа данных **particle** создается, инициализируется и затем сохраняется на диск в режиме неформатированного ввода-вывода. После сохранения данных на диск они считываются обратно с помощью неформатированного ввода-вывода и выводятся на стандартный вывод. Листинг показан ниже:

```fortran
program unformatted_io_2
	
    implicit none
	
    ! ---- Определите некоторые константы программы	
    integer, parameter :: iw = 15
    integer, parameter :: ir = 16
    integer, parameter :: nParticles = 1000
	
    ! ---- Определите тип данных частиц	
    type particle
        real :: position(3)
        real :: velocity(3)
        real :: mass
    end type particle
	
    ! ---- Переменные программы
    integer :: i
	
    ! ---- Распределяемый массив частиц
    type(particle), allocatable :: particles(:)
	
    allocate(particles(nParticles))
	
    ! ---- Инициализация массива частиц
    do i=1,nParticles
        particles(i)%position = 0.0
        particles(i)%velocity = 0.0
        particles(i)%mass = 1.0
    end do
	
    ! ---- Запишите все частицы на диск
    open(unit=iw, file='particles.dat', form='unformatted', status='replace')
    write(unit=iw) particles
    close(unit=iw)
	
    ! ---- Деаллокация массива частиц
    deallocate(particles)
	
    ! ---- Выделите новый массив и считайте данные с диска
    allocate(particles(nParticles))
	
    open(unit=ir, file='particles.dat', form='unformatted')
    read(unit=ir) particles
    close(unit=ir)
	
    ! ---- Выведите содержимое массива
    print*, particles
	
    ! ---- Деаллокация массива
    deallocate(particles)
	
end program unformatted_io_2
```

При запуске код выдал следующий результат:
$ ./unformatted_io_2
0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000 ....

Это означает, что данные были корректно считаны с диска.
### Файлы прямого доступа
Разновидностью неформатированного ввода-вывода являются файлы прямого доступа. Одна из проблем неформатированного ввода-вывода заключается в том, что файлы приходится читать и записывать последовательно. Это делает его неэффективным, если вы хотите получить доступ к определенным частям файла в произвольном порядке. Для решения этой проблемы в Fortran предусмотрен формат файлов прямого доступа. В этом формате файл делится на несколько равноудаленных друг от друга записей данных. Эти записи можно произвольно считывать из одного файла. Это можно сравнить с файлом базы данных с записями данных.

Чтобы создать файл прямого доступа, состоящий из записей следующего производного типа данных,
```fortran
type account
    character(len=40) :: account_holder
    real :: balance
end type account
```

необходимо рассчитать размер записи данных. Это можно сделать с помощью функции **inquire**. Она присваивает переменной размер записи типа данных, как показано в следующем листинге:
```fortran
type(account) :: account
integer :: recordSize
...
inquire(iolength=recordSize) account
```

Переменная **recordSize** теперь может использоваться при создании файла прямого доступа с помощью **open**-statement:
```fortran
open(unit=iw, file='accounts.dat', access='direct', recl=recordSize, status='replace')
```
Запись записей осуществляется с помощью обычного **write**-statement с добавлением **rec**-option для указания позиции записи, которая должна быть записана.
```fortran
write(iw, rec=1) account
```
При записи можно записывать в любую позицию записи. Чтение записи осуществляется с помощью **read**-статей с использованием **rec**-опции.

При чтении или записи в файлы прямого доступа существует невидимый курсор или указатель, указывающий на текущую запись. Этим курсором можно манипулировать с помощью **rewind**- и **backspace**-выражений. Операция **rewind** перемещает указатель на первую запись в файле. Операция **backspace** перемещает указатель на одну запись назад в файле, эти операции проиллюстрированы на следующем рисунке.
![[io_rewind_backspace.svg|1200]]
Рис. 3 **rewind**- и **backspace**-высказывания

Также можно усечь файл прямого доступа в заданной позиции с помощью оператора **endfile**, как показано на следующем рисунке. Все записи после текущей записи будут усечены.
![[io_endfile.svg|600]]
Рис. 4 Усечение файла с помощью оператора **endfile**.

Следующий код показывает полный пример записи записей в файл прямого доступа:
```fortran
program unformatted_io
	
    implicit none
	
    integer, parameter :: iw = 15
    type account
    character(len=40) :: account_holder
    real :: balance
    end type account
	
    type(account) :: accountA
    type(account) :: accountB
    integer :: recordSize
	
    inquire(iolength=recordSize) accountA
	
    print *, 'Record size =',recordSize
	
    accountA%account_holder = 'Olle'
    accountA%balance = 400
	
    accountB%account_holder = 'Janne'
    accountB%balance = 800
	
    open(unit=iw, file='bank.dat', access='direct', recl=recordSize, status='replace')
    write(iw, rec=1) accountA
    write(iw, rec=2) accountB
    close(unit=iw)
	
end program unformatted_io
```
### Обработка ошибок при операциях ввода/вывода
Одна из проблем чтения и записи файлов заключается в том, что на системном уровне могут возникать ошибки, такие как нехватка места на диске, проблемы с файловой системой и отсутствие файлов. Если с ними не справиться, программа аварийно завершит работу и не сможет выполнить надлежащий код очистки. В Фортране ошибки ввода-вывода обрабатываются с помощью **err**-опции во всех функциях, связанных с вводом-выводом. С помощью **err**-опции можно определить метку, на которой будет продолжено выполнение при возникновении ошибки ввода-вывода.

В следующем коде файл открывается для чтения. Код обработки ошибок добавляется для каждой операции ввода-вывода, обеспечивая различные метки и реакцию для всех состояний ошибки.
```fortran
program error_handling
	
    implicit none
	
    integer, parameter :: ir = 15
    integer :: a
	
    open(unit=ir, file='test.txt', status='old', err=101)
    read(ir,*,err=102) a
    close(unit=ir,err=103)
	
    stop
	
101 print *, 'An error occured when opening the file.'
	
    stop
	
102 print *, 'An error occured when reading the file.'
	
    stop
	
103 print *, 'An error occured when closing the file.'
	
    stop
	
end program error_handling
```

Рис. 5 показывает поток программы.
![[error_handling.svg|400]]
Также можно определить причину ошибки с помощью опции **iostat**. С опцией **iostat** связана переменная, и при возникновении ошибки переменной будет присвоен код ошибки. В следующем коде показан пример использования этой опции:
```fortran
integer :: ierr
...
open(..., iostat=ierr)
...
read(unit=xx, iostat=ierr)
...
close(unit=xx, iostat=ierr)
```

Если ошибка не возникла, связанной переменной присваивается код ошибки 0. Другие коды могут быть:
> •  -2, Условие конца записи возникает при непродвигающемся вводе/выводе.
> •  -1, Условие конца файла.
> • >1, Стандартизированный список кодов ошибок фортрана.

При использовании **iostat**-опции все сообщения об ошибках по умолчанию будут подавлены, и выполнение кода продолжится. Лучше всего использовать эту опцию в сочетании с **err**-опцией для предоставления пользователям ясных сообщений об ошибках, как показано в следующем примере кода:
```fortran
subroutine read_from_file(...)
    ...
    integer :: ierr
    ...
    read(unit=xx, err=101, iostat=ierr)
    ...
    return
	
101 print*, 'Error ', ierr, ' reading file.'
    return
	
end subroutine
```
