В научных и технических приложениях матрицы и массивы являются важными понятиями. Поскольку Fortran - это язык, предназначенный в основном для технических вычислений, массивы и матрицы играют в нем важную роль.

Объявление массивов и матриц может быть выполнено двумя способами. При первом способе размеры указываются с помощью специального атрибута **dimension** после объявления типа данных. При втором способе размерность указывается путем добавления размерности непосредственно после имени переменной. Приведенный ниже код иллюстрирует эти способы объявления массивов.
```fortran
integer, parameter :: dp = selected_real_kind(15,300)
real(dp), dimension(20,20) :: K ! Матрица 20x20 элементов
real(dp) :: fe(6) ! Массив из 6 элементов
```

По умолчанию начальный индекс в массивах равен 1. Однако в объявлении можно задавать собственные индексы, как показано в следующем примере.
```fortran
real(ap) :: idx(-3:3)
```
Здесь объявляется массив **idx** с индексами [-3, -2, -1, 0, 1, 2, 3], который содержит 7 элементов.
### Назначение массива
Массивам присваиваются значения либо по явным индексам, либо по всему массиву в одном операторе. Следующий код присвоил переменной **K** значение 5.0 в строке 5 и столбце 6.
```fortran
K(5,6) = 5.0_dp
```

Если бы задание было написано так
```fortran
K = 5.0_dp
```
Всему массиву **K** было бы присвоено значение 5.0. Это эффективный способ присвоения начальных значений целым массивам.

Явные значения можно присваивать массивам в одном операторе с помощью следующего присваивания.
```fortran
real(dp) :: v(5) ! Array with 5 elements
v = (/ 1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp /)
```

Это эквивалентно присвоению с помощью следующих операторов.
```fortran
v(1) = 1.0_dp
v(2) = 2.0_dp
v(3) = 3.0_dp
v(4) = 4.0_dp
v(5) = 5.0_dp
```
Количество элементов в списке должно быть равно количеству элементов в переменной массива.

Присвоение определенным частям массивов может быть достигнуто с помощью нарезки. Следующий пример иллюстрирует эту концепцию.
```fortran
program slicing

    implicit none
    real :: A(4,4)
    real :: B(4)
    real :: C(4)

    B = A(2,:) ! Assigns B the values of row 2 in A
    C = A(:,1) ! Assigns C the values of column 1 in A

    stop

end program slicing
```

С помощью нарезки строки или столбцы могут быть назначены в одном операторе, как показано в следующем коде:
```fortran
! Assign row 5 in matrix K the values 1, 2, 3, 4, 5
K(5,:) = (/ 1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp /)

! Assign the array v the values 5, 4, 3, 2, 1
v = (/ 5.0_dp, 4.0_dp, 3.0_dp, 2.0_dp, 1.0_dp /)
```
### Массивные выражения
В современном Фортране выражения можно использовать и для массивов. При этом операторы будут применяться к элементам выражения. Чтобы это работало, массивы должны быть одинакового размера. Выражение массива может также содержать скалярные значения. Они будут транслироваться в элементы массива. Рассмотрим следующие массивы:
```fortran
real :: a(10,20), b(10,20), c(10,20)
real :: u(5), v(5)
```
Следующее выражение разделит все значения в **a** на значения в **b**.
```fortran
c = a/b
```

Это эквивалентно:
```fortran
do i=1,10
    do j=1,20
        c(i,j) = a(i,j)/b(i,j)
    end do
end do
```
Важно убедиться, что результирующая переменная в левой части присваивания имеет тот же размер, что и результирующее выражение массива.

Следующее выражение добавляет скалярное значение ко всем элементам массива **v**:
```fortran
u = v + 1.0
```

Это эквивалентно:
```fortran
do i=1,5
    u(i) = v(i) + 1.0
end do
```

Также можно использовать нарезку для извлечения ''кусочка'', который можно использовать в выражении массива:
```fortran
u = 5.0/v + a(1:5,5)
```

Что эквивалентно:
```fortran
do i=1,5
    u(i) = 5.0/v(i) + a(i,5)
end do
```
### Массивное хранение
Операционная система выделяет память линейными блоками байтов. В операционной системе отсутствует понятие многомерных массивов. Это понятие ввел язык программирования, в данном случае Fortran, чтобы облегчить нам реализацию алгоритмов и доступ к значениям, хранящимся в памяти.

Существует два способа хранения двумерных массивов в памяти: по столбцам и по строкам. В Fortran принято хранить массивы по столбцам, а в C - по строкам. Следующий рисунок иллюстрирует эту концепцию:
![[array_storage.webp|800]]
Рис. 1 Массивы в памяти.

Хранение массивов в памяти особенно важно при вызове библиотек, реализованных на других языках, которые обычно хранят массивы по строкам. Библиотека Python NumPy по умолчанию хранит все массивы, используя соглашение C. Вызов подпрограммы Fortran с указателем на эти массивы, скорее всего, приведет к неопределенному поведению. NumPy поддерживает массивы, упорядоченные по столбцам, для чего в конструктор массива добавляется опция pkeyw{order=F}.
### Распределяемые массивы
В Fortran 77 и более ранних версиях стандарта не было возможности динамически выделять память во время выполнения программы. Теперь эта возможность доступна в Fortran 90 и более поздних версиях. Чтобы объявить массив динамически выделяемым, к объявлению массива необходимо добавить атрибут **allocatable**. Размерность также заменяется двоеточием, :, указывающим на количество размерностей в объявленной переменной. Типичное объявление массива с возможностью выделения показано в следующем примере.
```fortran
real, dimension(:,:), allocatable :: K
```

В этом примере двумерный массив, K, определен как распределяемый. Чтобы указать, что массив является двумерным, в атрибуте переменной указывается **dimension(:,:)**. Для объявления одномерного массива код выглядит следующим образом:
```fortran
real, dimension(:), allocatable :: f
```

Переменные с атрибутом **allocatable** не могут быть использованы до тех пор, пока не будет выделена память. Выделение памяти происходит с помощью метода **allocate**. Для выделения переменных **K,f** в предыдущих примерах используется следующий код.
```fortran
allocate(K(20,20))
allocate(f(20))
```

Когда выделенная память больше не нужна, ее можно деаллоцировать с помощью команды **deallocate**, как показано в следующем коде.
```fortran
deallocate(K)
deallocate(f)
```
Важным моментом при использовании динамически распределяемых переменных является обеспечение того, чтобы приложение не "утекало". Термин "утечка" используется для приложений, которые выделяют память во время выполнения и никогда не деаллоцируют использованную память. Если не следить за этим, приложение будет использовать все больше и больше ресурсов и в конечном итоге заставит операционную систему начать свопинг и, возможно, также станет нестабильной. Правило заключается в том, что оператор **allocate** всегда должен иметь соответствующий оператор **deallocate**.
### Объекты массива
Во многих ситуациях требуется работать с меньшими частями или фрагментами существующих массивов. В современном Фортране это можно сделать с помощью функции подобъектов. Мы проиллюстрируем концепцию подобъектов на примере. Рассмотрим следующие объявления двумерного и одномерного массивов:
```fortran
use utils

real(dp) :: A(10,10)
real(dp) :: v(10)
```
Чтобы убедиться, что в массивах нет ненужных значений, мы инициализируем их случайными значениями от 1 до 0.
```fortran
call init_rand()
call set_print_format(10, 4, 'F')

call rand_mat(A, 0.0_dp, 1.0_dp)
call rand_vec(v, 0.0_dp, 1.0_dp)
```

Мы распечатаем массивы, чтобы увидеть их структуру:
```fortran
call print_matrix(A, 'a')
print*, loc(A)

call print_vector(v, 'c')
print*, loc(v)
```
Принт-статьи добавлены, чтобы показать фактический адрес памяти, чтобы мы могли видеть, что происходит, когда мы создаем подобъекты.

Matrix a(10 x 10) DP
--------------------------------------------------------------------------...
    0.7112    0.6538    0.9200    0.7415    0.7460    0.4596    0.9778 ... 
    0.4111    0.0399    0.7354    0.9505    0.4428    0.7871    0.7390 ...
    0.9814    0.4057    0.4292    0.3406    0.6673    0.2120    0.9523 ...
    0.1369    0.5396    0.4405    0.7577    0.9942    0.7274    0.2653 ...
    0.7179    0.9883    0.5549    0.6374    0.1337    0.9464    0.7786 ...
    0.2915    0.8634    0.3962    0.8088    0.5708    0.9827    0.8841 ...
    0.8294    0.8191    0.5452    0.2079    0.1126    0.8199    0.2020 ...
    0.0706    0.6945    0.7744    0.3474    0.2566    0.6155    0.0921 ...
    0.3754    0.7855    0.9828    0.3965    0.9551    0.2119    0.2718 ...
    0.4026    0.5287    0.6198    0.9967    0.5866    0.6598    0.4024 ...
--------------------------------------------------------------------------...
    140722079206560

Vector c ( 10) DP
------------------------------------------------------------------------- ...
    0.9092    0.4976    0.6361    0.0355    0.7865    0.2197    0.8824 ...
------------------------------------------------------------------------- ...
    140722079206480

В первом примере мы выводим первый столбец массива **A**:
```fortran
call print_vector(A(:,1))
print*, loc(A(:,1))
```

В результате мы получим следующий результат:

Vector (10)
------------------------------------------------------------------------- ...
    0.7112    0.4111    0.9814    0.1369    0.7179    0.2915    0.8294 ...
------------------------------------------------------------------------- ...
    140722079206560

Из вывода видно, что i, по-видимому, является первым столбцом массива **A**. Мы также видим, что местоположение памяти подобъекта эквивалентно местоположению памяти **A**-массива. Это связано с тем, что память для массива **A** хранится по столбцам, и доступ к срезу в этом направлении может быть осуществлен напрямую, без копирования.

Если вместо этого извлечь первую строку **A**-массива:
```fortran
call print_vector(A(1,:))
print*, loc(A(1,:))
```

Мы получаем следующий результат:

Vector ( 10)
------------------------------------------------------------------------- ...
    0.7112    0.6538    0.9200    0.7415    0.7460    0.4596    0.9778 ...
------------------------------------------------------------------------- ...
    0278912

Здесь мы видим, что ячейка памяти находится в совершенно другом месте. Это связано с тем, что компилятору необходимо сделать временную копию для создания этого фрагмента. Об этом важно помнить, особенно если вы работаете с большими фрагментами массивов, которые передаются в вызовах подпрограмм. Это может привести к сбоям, поскольку такие фрагменты часто выделяются в стеке.

Ниже показаны некоторые другие примеры использования подобъектов массива:
```fortran
call print_matrix(A(1:2,1:2))

call print_matrix(A(1:6:2,1:6:2))
print*, loc(A(1:6:2,1:6:2))

call print_matrix(A(:,1:2))
print*, loc(A(:,1:2))
```
Это дает следующий результат:
Matrix (2 x 2) DP
----------------------------
	0.1233    0.2606
	0.8357    0.4479
--------------------
    27678720

Matrix (  3 x   3) DP
-----------------------------------------
    0.1233    0.7812    0.1668
    0.4284    0.3687    0.6542
    0.2531    0.3314    0.3557
------------------------------
    27689200

Matrix ( 10 x   2) DP
----------------------------
    0.1233    0.2606
    0.8357    0.4479
    0.4284    0.2254
    0.3541    0.3400
    0.2531    0.6490
    0.6420    0.5396
    0.5006    0.5849
    0.7185    0.3138
    0.8209    0.6203
    0.0232    0.9131
--------------------
    140728814257696