[Работа с памятью в языке С](<## 1. Типы памяти в C
В языке C память делится на несколько областей:
#### Стек (Stack):
* Используется для хранения локальных переменных функций.
* Память выделяется и освобождается автоматически при входе и выходе из функции.
* Размер стека ограничен, поэтому большие структуры данных лучше размещать в куче.
```c
void foo() {
	int x = 10; // Переменная x размещается в стеке
}
```

#### Куча (Heap):
* Память выделяется динамически с помощью функций `malloc`, `calloc`, `realloc` и освобождается с помощью `free`.
* Размер кучи ограничен только объемом оперативной памяти.
* Программист сам управляет выделением и освобождением памяти.
```c
int *arr = malloc(10 * sizeof(int)); // Выделение памяти для массива из 10 int
free(arr); // Освобождение памяти
```

#### Глобальная и статическая память:
* Используется для хранения глобальных и статических переменных.
* Память выделяется на время выполнения программы.
```c
int global_var = 42; // Глобальная переменная

void bar() {
	static int static_var = 0; // Статическая переменная
}
```

---
## 2. Динамическое выделение памяти
Динамическое выделение памяти позволяет программисту запрашивать память во время выполнения программы. Для этого используются следующие функции:
#### malloc:
* Выделяет блок памяти указанного размера.
* Возвращает указатель на начало выделенного блока.
* Память не инициализируется.
```c
int *arr = malloc(10 * sizeof(int)); // Выделение памяти для 10 int
if (arr == NULL) {
	// Обработка ошибки выделения памяти
}
```

#### calloc:
* Выделяет память и инициализирует её нулями.
* Принимает два аргумента: количество элементов и размер каждого элемента.
```c
int *arr = calloc(10, sizeof(int)); // Выделение памяти для 10 int, инициализированных нулями
```

#### realloc:
* Изменяет размер ранее выделенного блока памяти.
* Может переместить блок памяти на новое место, если это необходимо.
```c
arr = realloc(arr, 20 * sizeof(int)); // Увеличение размера массива до 20 int
```

#### free:
* Освобождает память, выделенную с помощью malloc, calloc или realloc.
* После вызова free указатель становится недействительным.
```c
free(arr); // Освобождение памяти
```

---

## 3. Указатели и работа с памятью
Указатели — это переменные, которые хранят адреса других переменных или областей памяти. Они играют ключевую роль в работе с памятью в C.

#### Объявление указателя:    
```c
int *ptr; // Указатель на int
```

#### Разыменование указателя:
```c
int x = 10;
int *ptr = &x; // ptr хранит адрес переменной x
int y = *ptr;  // y = 10 (значение по адресу, хранящемуся в ptr)
```

#### Арифметика указателей:
* Указатели можно увеличивать или уменьшать для перемещения по массиву или структуре.
```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr; // ptr указывает на первый элемент массива
ptr++; // Теперь ptr указывает на второй элемент массива
```

---
## 4. Распространенные ошибки при работе с памятью

#### Утечки памяти:
* Происходят, если память выделена, но не освобождена.
```c
void leak() {
	int *ptr = malloc(10 * sizeof(int));
	// Забыли вызвать free(ptr)
}
```

#### Выход за границы массива:
* Попытка доступа к памяти за пределами выделенного блока.
```c
int arr[5];
arr[5] = 10; // Ошибка: выход за границы массива
```

#### Использование неинициализированной памяти:
* Попытка работы с памятью, которая не была инициализирована.
```c
int *ptr;
*ptr = 10; // Ошибка: ptr не инициализирован
```

#### Двойное освобождение памяти:
* Попытка освободить уже освобожденную память.
```c
int *ptr = malloc(sizeof(int));
free(ptr);
free(ptr); // Ошибка: двойное освобождение
```

#### Использование памяти после освобождения:
* Попытка работы с памятью после вызова `free`.
```c
int *ptr = malloc(sizeof(int));
free(ptr);
*ptr = 10; // Ошибка: использование памяти после освобождения
```

---
## 5. Советы по работе с памятью
* Всегда проверяйте результат вызова `malloc`, `calloc` и `realloc` на `NULL`.
* Освобождайте память сразу, как она становится не нужна.
* Используйте инструменты для отладки памяти, такие как Valgrind.
* Избегайте "висячих указателей" (dangling pointers) — указателей на освобожденную память.
* Для работы со строками используйте функции, которые контролируют длину, например `strncpy` вместо `strcpy`.

#### 1. Пример работы с памятью
```c
#include %3Cstdio.h%3E
#include <stdlib.h>
#include <string.h>

int main() {
	// Выделение памяти для массива из 5 int
	int *arr = malloc(5 * sizeof(int));
	if (arr == NULL) {
		perror("Ошибка выделения памяти");
		return 1;
	}

	// Инициализация массива
	for (int i = 0; i < 5; i++) {
		arr[i] = i * 2;
	}

	// Увеличение размера массива до 10 int
	arr = realloc(arr, 10 * sizeof(int));
	if (arr == NULL) {
		perror("Ошибка перевыделения памяти");
		return 1;
	}

	// Освобождение памяти
	free(arr);

	return 0;
}
```
[[C]] [[Работа памяти]]